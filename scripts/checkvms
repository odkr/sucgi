#!/bin/sh

#
# Run checks using different systems.
#
# Copyright 2023 Odin Kroeger.
#
# This file is part of suCGI.
#
# suCGI is free software: you can redistribute it and/or modify it
# under the terms of the GNU Affero General Public License as published
# by the Free Software Foundation, either version 3 of the License,
# or (at your option) any later version.
#
# suCGI is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
# or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General
# Public License for more details.
#
# You should have received a copy of the GNU Affero General Public
# License along with suCGI. If not, see <https://www.gnu.org/licenses/>.
#

# shellcheck disable=2015


#
# Defaults
#

# Hosts to test on.
readonly systems='aristides aristotle diotima phaedo phaedrus'

# Branch to run tests on.
branch=devel

# Check command to run.
check="
	if command -v sudo >/dev/null
	then sudo scripts/checkall -v
	elif command -v doas >/dev/null
	then doas scripts/checkall -v
	else scripts/checkall -v
	fi
"

# Repository directory on the virtual machine.
dir='repos/sucgi'

# Be quieter?
quiet=

# Be verbose?
verbose=

# How many seconds to wait for a VM to become reachable.
timeout=120


#
# Initialiation
#

set -Cefu
scripts_dir="$(cd -P "$(dirname -- "$0")" && pwd)"
: "${scripts_dir:?}"
readonly scripts_dir

src_dir="$(dirname -- "$scripts_dir")"
: "${src_dir:?}"
readonly src_dir

# shellcheck disable=2154
export PATH="$src_dir/tests:$src_dir/utils:$PATH"

# shellcheck disable=1091
. "$scripts_dir/libutil.sh"	|| exit
init				|| exit
tmpdir chk "$src_dir"		|| exit


#
# Constants
#

# Current working directory
cwd="$(pwd)" || exit
readonly cwd


#
# Functions
#

utm_get_ip() {
	utmctl ip-address "${1:?}" 2>/dev/null | grep -Ev ^fe80: | head -n1
}

utm_is_vm() {
	# shellcheck disable=2046
	inlist '=' "${1:?}" $(utmctl list | awk 'NR > 1 {print $3}')
}

utm_quit() {
	utm_stop_last_vm
	if command -v osascript >/dev/null 2>&1
	then osascript -e 'tell application "UTM" to quit'
	else killall UTM
	fi
}

utm_quit_at_exit() {
	if [ "${utmpid-x}" = x ] && [ "${utmpid-}" != x ]
	then
		utmpid="$(
			ps -xo pid=,comm= |
			awk '$2 ~ /\/UTM$/ {print $1; exit}'
		)"
		readonly utmpid
	fi

	if ! [ "$utmpid" ]
	then
		case $cleanup in
		(*utm_quit*) : ;;
		(*) cleanup="utm_quit; ${cleanup-}"
		esac
	fi
}

utm_status() {
	utm_quit_at_exit
	utmctl status "${1:?}" 2>/dev/null
}


utm_stop_last_vm() {
	if	[ "${lastvm-}" ]			&&
		[ "$(utm_status "$lastvm")" = started ]	>/dev/null 2>&1
	then
		catch=
		utmctl stop "$lastvm"
		lastvm=
		# shellcheck disable=2034
		catch=x
		if [ "$caught" ]
		then kill -s "$caught" "$$"
		fi
	fi
}

utm_start_vm() {
	utm_quit_at_exit
	if	status="$(utm_status "${1:?}")" &&
		[ "$status" = stopped ]
	then
		lastvm="$1"
		utmctl start "$1"
	fi
}



#
# Options
#

OPTIND=1 OPTARG='' opt=''
# shellcheck disable=2034
while getopts Db:c:d:hqt:v opt; do
	# shellcheck disable=2154
	case $opt in
	(h) exec cat <<EOF
$progname - run tests with different virtual machines

Usage:         $progname [HOST ...]
               $progname -h

Operands:
    HOST       A host/UTM virtual machine name.

Options:
    -b BRANCH  Branch to checkout (default: $branch).
    -c CHECK   Check to run (default: $check).
    -d DIR     Repository directory on VM (default: $dir).
    -t N       Wait at most N seconds for VM to boot (default: $timeout).
    -q         Be quieter.
    -v         Be verbose, but do not log runs.
    -h         Show this help screen.
EOF
	    ;;
	(D) set -x ;;
	(b) branch="$OPTARG" ;;
	(c) check="$OPTARG" ;;
	(d) dir="$OPTARG" ;;
	(t) timeout="$OPTARG" ;;
	(q) quiet=y ;;
	(v) verbose=y ;;
	(*) exit 1
	esac
done
shift $((OPTIND - 1))
unset opt

# shellcheck disable=2086
[ $# -eq 0 ] && set -- $systems

readonly comm="
	set -ex
	cd \"$dir\"
	git stash
	oldbranch=\"\$(git branch)\"
	git checkout \"$branch\"
	$check || retval=$?
	git checkout \"\$oldbranch\"
	exit \"\$retval\"
"


#
# Main
#

failures=
for sys
do
	warn 'checking with %s ... ' "$sys"

	[ "$verbose" ] && warn -q 'waiting for %s to respond ...' "$sys"

	if utm_is_vm "$sys"
	then vm="$sys"
	else vm=
	fi

	[ "$vm" ] && utm_start_vm "$vm"

	trap 'catch ALRM' ALRM
	pid="$$"
	( sleep "$timeout" & wait $! && kill -s ALRM "$pid"; ) & alarm=$!

	while ! [ "$caught" ]
	do
		if [ "$vm" ] && ip="$(utm_get_ip "$vm")"
		then host="${ip:="$vm"}"
		else host="$sys"
		fi

		ssh "$host" -oConnectTimeout=1 true >/dev/null 2>&1 && break
	done

	[ "$caught" = ALRM ] && err 'connection failure.'
	kill "$alarm"

	[ "$verbose" ] && warn -q 'updating remote repository ...'
	logged git push --all --prune "ssh://$host/~/$dir"

	logfile="$TMPDIR/$sys.log"
	if ! (
		[ "$verbose" ] || exec >"$logfile" 2>&1

		# shellcheck disable=2029
		ssh "$host" "$comm"
	)
	then
		if ! [ "$verbose" ]
		then
			warn 'testing with %s failed.' "$sys"
			warn 'see %s for details.' "$(basename "$logfile")"
			[ -e "$logfile" ] && mv -f "$logfile" "$cwd"
		fi
		failures="$failures $sys"
	fi

	[ "$vm" ] && utm_stop_last_vm
done

if [ "$failures" ]
then err -s70 'failures: %s' "${failures# }"
else warn -q 'all tests passed.'
fi
