#!/bin/sh
# Generate a build configuration.
#
# Copyright 2022 and 2023 Odin Kroeger.
#
# This file is part of suCGI.
#
# suCGI is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option)
# any later version.
#
# suCGI is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
# for more details.
#
# You should have received a copy of the GNU General Public License along
# with suCGI. If not, see <https://www.gnu.org/licenses>.

# shellcheck disable=1091,2015


#
# Defaults
#

# Search static code analysers?
searchstat=

# Compiler flags to test for.
cflags=

# Compilers to look for. Space-separated list of commands.
compilers='gcc clang tcc icx icc c99 cc'

# Flags used for testing compiling features.
compflags=

# Configuration file.
conf=prod.env

# Files to generate. Space-separated list.
files='build.h makefile'

# Overwrite existing files?
force=

# Maximum number of child processes to spawn.
maxnjobs=4
# The Almquist shell tends to crash when running jobs in parallel.
[ "$(basename "${SHELL-}")" = ash ] && maxnjobs=1

# Be quiet?
quiet=

# Directories to add to $PATH when searching utilities. Colon-separated list.
statpath=


#
# Initialisation
#

set -Ceu
src_dir="$(dirname "$0")" || exit
readonly src_dir
cd "$src_dir" || exit
. ./scripts/funcs.sh || exit
init
tmpdir tmp .


#
# Constants
#

# Variables to set as M4 Macros.
readonly macros='
	CC CFLAGS AR ARFLAGS LDFLAGS LDLIBS DESTDIR PREFIX
	SC_CGI_DIR SC_WWW_GRP
	SC_CLANG_TIDY SC_CPPCHECK SC_FLAWFINDER SC_RATS SC_SHELLCHECK
'

# Where to save the configuration.
readonly confsave=config.status

# Colon-separated list of integer types used for group IDs and sizes.
inttypes=
for base in 'int' 'long' 'long long'
do
	for prefix in '' 'unsigned '
	do inttypes="$inttypes:$prefix$base"
	done
done
unset base
readonly inttypes

# Colon-separated list of possible data types for group IDs.
readonly grouptypes="gid_t:$inttypes"

# Colon-separated list of possible data types for sizes.
readonly sizetypes="size_t:$inttypes"


#
# Functions
#

# Check if the given compiler supports the given flags.
addflags() {
	case ${1:?} in
	(-*)
		cflags="${cflags-} $*"
		;;
	(*)
		__addflags_var="cflags_$1"
		shift
		eval "$__addflags_var"="\"\${$__addflags_var-} \$*\""
		unset __addflags_var
		;;
	esac
}

# Print the value of $macro from $CFLAGS.
getmacroval() (
	macro="${1:?}"

	eval "set -- $CFLAGS"
	for flag
	do
		case $flag in (-D$macro=*)
			printf '%s\n' "${flag##-D$macro=}"
			return 0
		esac
	done

	return 1
)

# Test compilation.
testcomp() (
	: "${compname:?}"

	exec >/dev/null 2>&1

	case $compname in
	(clang|gcc)
		# shellcheck disable=2086
		"$CC" -xc -Wall -Werror $compflags -o/dev/null "$@"
		;;
	(tcc)
		# TCC unlinks /dev/null when given -o/dev/null.
		# shellcheck disable=2086
		"$CC" -Wunsupported \
		      -xc -Wall -Werror $compflags -o"$TMPDIR/a.out" "$@"
		;;
	(icc)
		# shellcheck disable=2086
		"$CC" -diag-enable=10006,10148 -diag-error=10006,10148 \
		      -xc -Wall -Werror $compflags -o/dev/null "$@"
		;;
	(*)
		return 1
		;;
	esac
)

# Test compiler flags.
testflags() {
	printf 'int main(void) {return 0;}\n' |
	testcomp "$@" -
}

# Test whether a header file is available.
testhdr() {
	printf '#include <%s>\n' "${1:?}" |
	testcomp -E -
}


#
# Options
#

OPTIND=1 OPTARG='' opt=''
while getopts Dc:dfhj:p:qs opt; do
	# shellcheck disable=2154
	case $opt in
	(h) exec cat <<EOF >&2
$prog_name - generate a build configuration

Usage:       $prog_name [-cFILE|-d] [-f] [-jN] [-pDIR] [-q] [-s] [FILE ...]
             $prog_name -h

Operands:
    FILE     A file to generate (default: $files).

Options:
    -c FILE  Read build configuration from FILE (default: $conf).
    -d       Short for -c devel.env.
    -f       Overwrite existing files. config.h is never overwritten.
    -j N     Run N configuration tests in parallel (default: $maxnjobs).
    -p DIR   Add DIR to the search path for static analysers.
    -s       Search for static code analysers.
    -q       Be quiet.
    -h       Show this help screen.

See docs/build.rst for details.

Copyright 2022 and 2023 Odin Kroeger.
Released under the GNU General Public License.
This programme comes with ABSOLUTELY NO WARRANTY.
EOF
		;;
	(D) set -x ;;
	(c) conf="$OPTARG" ;;
	(d) conf=devel.env ;;
	(f) force=x ;;
	(j) maxnjobs="$OPTARG" ;;
	(p) statpath="$statpath:$OPTARG" ;;
	(q) quiet=x ;;
	(s) searchstat=x ;;
	(*) exit 1
	esac
done
shift $((OPTIND - 1))
unset opt

[ "$conf" ]	|| err '-c: no filename given.'
[ -e "$conf" ]	|| err '%s: no such file.' "$conf"

# shellcheck disable=1090
case $conf in ([!/.]*)
	conf="./$conf"
esac

# shellcheck source=devel.conf
. "$conf" || exit

# shellcheck disable=2086
[ $# -eq 0 ] && set -- $files
unset files

nfiles=0
for file
do
	eval "file_$nfiles"='"$file"'
	nfiles=$((nfiles + 1))
done
shift $#

if [ "$prog_name" = "$confsave" ]
then
	exec >/dev/null
	force=x
fi

# shellcheck disable=2034
readonly conf force quiet maxnjobs nfiles


#
# Check if gcc, clang, tcc, or icc are available.
#

printf 'C compiler: '

: "${CC:=}"
if ! [ "$CC" ]
then
	for cc in $compilers
	do
		if	command -v "$cc" >/dev/null 2>&1 &&
			"$cc" -v 2>&1 | grep -q "$cc"
		then
			CC="$cc"
			break
		fi
	done

	if ! [ "$CC" ]
	then
		for cc in c99 cc
		do
			if command -v "$cc" >/dev/null 2>&1
			then
				CC="$cc"
				break
			fi
		done
	fi

	unset cc
fi

if ! [ "$CC" ]
then
	printf 'none found\a\n'
	exit 2
fi

# Compiler path.
set -- "$CC"
comppath="${1:?}"
readonly comppath

# Compiler executable.
compexec="$(basename "${comppath:?}")"
readonly compexec

# Compiler name.
case $compexec in
(musl-*) compname="${compexec##musl-}"
esac
compname="${compexec%%[!a-z]*}"
readonly compname

# Compiler command prefix.
case $compname in
(clang)	compprefix=llvm ;;
(*)	compprefix="$compname" ;;
esac

# Compiler version.
compvers="$(
	"$CC" -v 2>&1 |
	awk '{
		for (i = 1; i <= NF; i++) {
			if ($i ~ /^v?[0-9]+\.[0-9]+\./) {
				gsub("[^0-9\.]", "", $i);
				print $i;
				exit;
			}
		}
	}' 2>/dev/null
)"

if [ "$compvers" ]
then
	compmajor="${compvers%%.*}"
else
	case $compexec in
	(*[0-9]*)
		prefix="${compexec%%[0-9]*}"
	        compmajor="${compexec#"$prefix"}"
		;;
	(*)
		compmajor=
		;;
	esac
fi
readonly compvers compmajor

# Compiler flags useful for testing.
for flag in -Wextra -Wpedantic -pedantic -pipe
do testflags $flag && compflags="$compflags $flag"
done
readonly compflags

# Does the compiler support conversion warnings?
wconvflags='-Wincompatible-pointer-types -Wconversion -Wsign-conversion'
# shellcheck disable=2086
if testflags $wconvflags
then compwconv=y
else compwconv=
fi

# Output.
printf '%s\n' "$CC"


#
# Check which flags the C compiler supports.
#

printf 'Compiler flags:'

if [ "${CFLAGS-x}" = x ] && ! [ "${CFLAGS-}" = x ]
then
	if [ "$compname" = c99 ]
	then
		CFLAGS="-O2 -s"
		printf ' %s\n' "$CFLAGS"
	else
		eval specflags="\${cflags_$compprefix-}"

		# shellcheck disable=2086,SC2154
		set -- $cflags $specflags
		njobs=0 jobs=''
		while [ "$njobs" -gt 0 ] || [ $# -gt 0 ]
		do
			# Start jobs.
			while [ "$njobs" -lt "$maxnjobs" ] && [ $# -gt 0 ]
			do
				flag="$1"
				shift

				case $flag in (-D*)
					CFLAGS="${CFLAGS-} $flag"
					continue
				esac

				testflags "$flag" &

				njobs=$((njobs + 1)) jobs="$jobs$! "
				eval "flag_$!"='$flag'
			done

			# Collect the job on top of the pile.
			job="${jobs%% *}"
			if wait "$job"
			then
				eval flag="\"\${flag_$job-}\""
				unset "flag_$job"
				CFLAGS="${CFLAGS-} $flag"
				printf -- ' %s' "$flag"
			fi
			njobs=$((njobs - 1)) jobs="${jobs#* }"
			unset job
		done

		[ "${CFLAGS-}" ] || printf ' none detected'

		echo
	fi
else
	printf -- ' %s\a\n' "${CFLAGS:-none given}"
fi
unset cflags flag jobs job


#
# Check which archiver to use.
#

printf 'Archiver: '

if [ "${AR-x}" = x ] && ! [ "${AR-}" = x ]
then
	if [ "${compmajor-}" ]
	then archivers="
		$compprefix-ar-$compmajor
		$compprefix-ar$compmajor
		$compprefix-ar
	"
	else archivers="$compprefix-ar"
	fi

	for archiver in $archivers
	do
		if command -v "$archiver" >/dev/null 2>&1
		then
			AR="$archiver"
			break
		fi
	done

	printf '%s\n' "${AR-default}"
fi


#
# Check if features.h is available.
#

printf 'Headers: '

case ${CFLAGS-} in
(*-DHAVE_FEATURES_H=0*)
	printf -- '-\n'
	;;
(*-DHAVE_FEATURES_H=*|*"-DHAVE_FEATURES_H "*|*-DHAVE_FEATURES_H)
	printf -- 'features.h\n'
	;;
(*)
	if testhdr features.h
	then
		CFLAGS="-DHAVE_FEATURES_H=1 ${CFLAGS-}"
		printf 'features.h\n'
	else
		CFLAGS="-DHAVE_FEATURES_H=0 ${CFLAGS-}"
		printf 'none detected\n'
	fi
	;;
esac


#
# Check what data type getgrouplist returns GIDs as.
#

printf 'getgrouplist GID type: '

case ${CFLAGS-} in
(*-DGETGRPLST_T=*)
	getmacroval GETGRPLST_T
	;;
(*)
	found=
	if [ "$compwconv" ]
	then
		src="$TMPDIR/getgroups.c"
		cat <<-'EOF' >"$src"
			#define _BSD_SOURCE
			#define _DARWIN_C_SOURCE
			#define _DEFAULT_SOURCE
			#define _GNU_SOURCE

			#include <grp.h>
			#include <unistd.h>

			int
			main(void)
			{
				GETGRPLST_T basegid = 0;
				GETGRPLST_T groups[1] = {0};
				int n = 1;

				getgrouplist("dummy", basegid, groups, &n);

				return 0;
			}
		EOF

		IFS=:
		for grouptype in $grouptypes
		do
			unset IFS
			# shellcheck disable=2086
			if	testcomp $wconvflags \
				         -DGETGRPLST_T="$grouptype" "$src"
			then
				CFLAGS="-DGETGRPLST_T='$grouptype' $CFLAGS"
				found=x
				printf '%s\n' "$grouptype"
				break
			fi
		done
		unset src grouptype
	fi

	[ "$found" ] || printf 'guess at compile-time\n'
	unset found
esac


#
# Check what data type setgroups takes the group size as.
#

printf 'setgroups count type: '

case ${CFLAGS-} in
(*-DSETGRPNUM_T=*)
	getmacroval SETGRPNUM_T
	;;
(*)
	found=
	if [ "$compwconv" ]
	then
		src="$TMPDIR/setgroups.c"
		cat <<-'EOF' >"$src"
			#define _BSD_SOURCE
			#define _DARWIN_C_SOURCE
			#define _DEFAULT_SOURCE
			#define _GNU_SOURCE

			#include <sys/types.h>
			#include <grp.h>
			#include <unistd.h>

			int
			main(void)
			{
				SETGRPNUM_T ngroups = 0;
				gid_t gidset[1] = {0};

				(void) setgroups(ngroups, gidset);

				return 0;
			}
		EOF

		IFS=:
		for sizetype in $sizetypes
		do
			unset IFS
			# shellcheck disable=2086
			if 	testcomp $wconvflags \
					 -DSETGRPNUM_T="$sizetype" "$src"
			then
				CFLAGS="-DSETGRPNUM_T='$sizetype' $CFLAGS"
				found=x
				printf '%s\n' "$sizetype"
				break
			fi
		done
		unset src sizetype
	fi

	[ "$found" ] || printf 'guess at compile-time\n'
	unset found
esac


#
# Static Code Analysers
#

if [ "$searchstat" ]
then
	# Extend $PATH for search analysers.
	if [ "$statpath" ]
	then
		IFS=:
		for dir in $statpath
		do
			unset IFS
			case $PATH in
			("$dir":|:"$dir"|:"$dir":) : ;;
			(*) [ -e "$dir" ] && PATH="$dir:$PATH"
			esac
		done
		export PATH
	fi

	# Clang-tidy
	printf 'Clang-Tidy: '
	: "${SC_CLANG_TIDY=$(command -v clang-tidy 2>/dev/null)}"
	if [ "$SC_CLANG_TIDY" ]
	then printf '%s\n' "$SC_CLANG_TIDY"
	else printf 'not found\n'
	fi

	# Cppcheck
	printf 'Cppcheck: '
	: "${SC_CPPCHECK=$(command -v cppcheck 2>/dev/null)}"
	if [ "$SC_CPPCHECK" ]
	then printf '%s\n' "$SC_CPPCHECK"
	else printf 'not found\n'
	fi

	# Flawfinder
	printf 'Flawfinder: '
	: "${SC_FLAWFINDER=$(command -v flawfinder 2>/dev/null)}"
	if [ "$SC_FLAWFINDER" ]
	then printf '%s\n' "$SC_FLAWFINDER"
	else printf 'not found\n'
	fi

	# RATS
	printf 'RATS: '
	: "${SC_RATS=$(command -v rats 2>/dev/null)}"
	if [ "$SC_RATS" ]
	then printf '%s\n' "$SC_RATS"
	else printf 'not found\n'
	fi

	# ShellCheck
	printf 'ShellCheck: '
	: "${SC_SHELLCHECK=$(command -v shellcheck 2>/dev/null)}"
	if [ "$SC_SHELLCHECK" ]
	then printf '%s\n' "$SC_SHELLCHECK"
	else printf 'not found\n'
	fi
fi


#
# Generate M4 command line.
#

shift $#
for key in $macros
do
	eval "value=\"\${$key-}\""
	if [ "$value" ]
	then
		case $# in
		(0) set -- "-D__${key}=${value# }" ;;
		(*) set -- "$@" "-D__${key}=${value# }" ;;
		esac
	fi
done
unset key value


#
# Save configuration.
#

if [ -e "$confsave" ]
	then exists=x
	else exists=
fi

if [ "$prog_name" != "$confsave" ]
then
	if [ "$exists" ] && ! [ "$force" ]
	then
		err '%s exists, give -f to overwrite.' "$confsave"
	else
		swap="$TMPDIR/$confsave"

		cat <<-'EOF' >"$swap"
		#!/bin/sh
		# Last configuration detected by ./configure.

		EOF

		for key in $macros
		do
			case $key in (*[!A-Z_]*)
				continue
			esac

			eval "value=\"\${$key--}\""
			[ "$value" = - ] && continue
			# shellcheck disable=2016
			printf ': "${%s="%s"}"\n' "$key" "${value# }" >>"$swap"
		done
		unset key value

		printf '\n. ./configure\n' >>"$swap"

		chmod +x "$swap"

		mv -f "$swap" "$confsave"

		if [ "$exists" ]
			then warn -q 'updated %s.' "$confsave"
			else warn -q 'saved configuration in %s.' "$confsave"
		fi
	fi
fi

#
# Create files.
#

i=0
while [ "$i" -lt "$nfiles" ]
do
	eval file="\${file_$i}"
	template="$file.m4" i=$((i + 1))

	exists=
	# shellcheck disable=2154
	if [ -e "$file" ]
	then
		exists=x
		if ! [ "$force" ]
		then
			warn '%s exists.' "$file"
			continue
		fi
	fi

	swap="$TMPDIR/$file"
	if m4 "$@" "$template" >"$swap" 2>/dev/null
	then
		mv -f "$swap" "$file"
		if [ "$exists" ]
		then warn -q 'updated %s.' "$file"
		else warn -q 'generated %s.' "$file"
		fi
	else
		rm -f "$swap" || :
		err 'could not generate %s.' "$file"
	fi
	unset swap
done


#
# config.h
#

if [ -e config.h ]
then
	cmp -s config.h.sample config.h ||
	warn -q 'config.h and config.h.sample differ, keeping config.h.'
else
	warn -q 'copying config.h.sample to config.h.'
	cp config.h.sample config.h
fi
