#!/bin/sh
# shellcheck disable=1091,2015

#
# Initialisation
#

set -Ceu

readonly script_dir="${0%/*}"
. "$script_dir/scripts/utils.sh" || exit
init
tmpdir tmp .


#
# Constants
#

# Number of child processes to spawn.
readonly nchildren=4


#
# Functions
#

# Add flags to cflags.
add_cflags() {
	cflags="${cflags-} $*"
}

# Add macro definitions to cflags.
add_macros() {
	while [ $# -gt 0 ]
	do
		cflags="${cflags-} -D$1"
		shift
	done
}


#
# Options
#

# shellcheck disable=1091
. "$script_dir/configure.env" || exit

OPTIND=1 OPTARG='' opt=''
force='' quiet=''
while getopts fqh opt; do
	case $opt in
		(f) force=x ;;
		(q) quiet=x ;;
		(h) exec cat <<-EOF ;;
			configure - Generate build configuration.

			Options:
			    -f  Overwrite existing files.
			    -h  Show this help screen.
			    -q  Be quiet.

			Environment:
			    CC          The C compiler.
			    CFLAGS      Flags to pass to the C compiler.
			    PROJECTDIR  Top-level directory of the repository.

			See README.md for details.
			EOF
		(*) exit 8
	esac
done
shift $((OPTIND - 1))
unset opt

[ "$#" -gt 0 ] && abort 'too many operands.'
[ "$quiet" ] && exec >/dev/null


#
# Base directory
#

if [ "${PROJECTDIR-}" ]
then
	printf 'Project directory: '

	if ! isportable "$PROJECTDIR"
	then
		# shellcheck disable=2154
		echo "${red}name is not portable.$reset"
		unset PROJECTDIR
	elif ! [ -e "$PROJECTDIR" ]
	then
		# shellcheck disable=2154
		echo "${red}directory does not exist.$reset"
		unset PROJECTDIR
	elif ! [ -d "$PROJECTDIR" ]
	then
		# shellcheck disable=2154
		echo "${red}not a directory.$reset"
		unset PROJECTDIR
	else
		echo "$PROJECTDIR"
	fi
fi

if ! [ "${PROJECTDIR-}" ]
then
	if isportable "$script_dir"
		then PROJECTDIR="$script_dir"
		else PROJECTDIR=.
	fi
fi


#
# Check if gcc or clang are available.
#

printf 'C compiler: '

: "${CC:=}"
if ! [ "$CC" ]
then
	for cc in gcc clang tcc c99 cc; do
		if "$cc" -v 2>&1 | grep -q "$cc"; then
			CC="$cc"
			break
		fi
	done
fi

if [ "$CC" ] && command -v "$CC" >/dev/null 2>&1
then
	echo "$CC"
else
	CC=
	# shellcheck disable=2154
	echo "\a${red}none found.$reset"
fi


#
# Check which flags the C compiler supports.
#

: "${CFLAGS="${cflags-}"}"
if [ "$CC" ]
then
	printf 'Compiler flags:'

	# shellcheck disable=2086
	set -- $CFLAGS
	CFLAGS='' n=0 pids=''
	while [ $# -gt 0 ]
	do
		case $1 in (-D*)
			CFLAGS="$CFLAGS $1"
			shift
			continue
		esac

		"$CC" -xc -Werror "$1" -o/dev/null - <<-EOF >/dev/null 2>&1 &
			int main (void) { return 0; }
		EOF
		pids="$pids $!"
		eval "flag_$!"='$1'
		shift

		if [ $(($# % nchildren)) -eq 0 ]
		then
			for pid in $pids
			do
				if wait "$pid"
				then
					eval flag="\"\$flag_$pid\""
					unset "flag_$pid"
					[ "${flag-}" ] || continue;
					CFLAGS="$CFLAGS $flag"
					n=$((n + 1))
					printf ' %s' "$flag"
				fi
			done
			pids=
		fi
	done

	if [ "$n" -eq 0 ]
		then printf -- ' -\n'
		else echo
	fi

	unset cflags flag n pid
fi


#
# Create files
#

errc=0 filec=0 genc=0
for input in "$PROJECTDIR/"*.m4
do
	[ "$input" = "$PROJECTDIR/*.in" ] && break
	name="$(basename "$input")" ||
		abort "$input: failed to get basename."
	output="${name%.m4}"
	filec=$((filec + 1))

	# shellcheck disable=2154
	if [ -e "$output" ] && ! [ "$force" ]
	then
		if ! [ "$quiet" ]
		then
			printf '\a' >&2
			warn "${yellow}not overwriting $bold$output$reset," \
			"give $bold-f$reset to force."
		fi
		continue
	fi

	swap="$TMPDIR/$output"
	if m4	-D__CC="${CC-}"				\
		-D__CFLAGS="${CFLAGS# }"		\
		-D__PROJECTDIR="${PROJECTDIR%/}"	\
		"$input" >"$swap"
	then
		mv "$swap" "$output"
		genc=$((genc + 1))
		[ "$quiet" ] || warn "generated $bold$output$reset."
	else
		rm -f "$swap" || :
		errc=$((errc + 1))
		printf '\a' >&2
		warn "${red}failed to generate$bold$output$reset$red."
	fi
	unset swap
done

# shellcheck disable=2154
if ! [ "$quiet" ]
then
	if [ $errc -gt 0 ]
	then
		printf '\a' >&2
		warn "$red$bold$errc$reset$red of $bold$filec$reset" \
		"${red}file(s) could not be generated.$reset"
	elif [ $genc -lt $filec ]
	then
		printf '\a' >&2
		warn "$yellow$bold$genc$reset$yellow of $bold$filec$reset" \
		"${yellow}file(s) generated.$reset"
	else
		warn "$green$bold$genc$reset$green of $bold$filec$reset" \
		"${green}file(s) generated.$reset"
	fi
fi

exit $errc
