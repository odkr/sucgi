#!/bin/sh

#
# Generate a build configuration.
#
# Copyright 2022 and 2023 Odin Kroeger.
#
# This file is part of suCGI.
#
# SuCGI is free software: you can redistribute it and/or modify it
# under the terms of the GNU Affero General Public License as published
# by the Free Software Foundation, either version 3 of the License,
# or (at your option) any later version.
#
# SuCGI is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
# or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General
# Public License for more details.
#
# You should have received a copy of the GNU Affero General Public
# License along with suCGI. If not, see <https://www.gnu.org/licenses/>.
#

# shellcheck disable=1091,2015


#
# Defaults
#

# Compiler flags to test for. Space-separated list.
cflags=

# Compilers to look for. Space-separated list of commands.
compilers='gcc clang tcc icx icc c99 cc'

# Configuration file.
conf=conf/prod.env

# Files to generate. Space-separated list.
files='compat.h makefile'

# Overwrite existing files?
force=

# Headers to look for. Space-separated list of filenames.
headers='sys/param.h features.h security/pam_appl.h shadow.h'

# Libraries to look for. Space-separated list of library names.
libs=pam

# Maximum number of child processes to spawn.
maxnjobs=4
# The Busybox Almquist shell tends to crash when running jobs in parallel.
[ "$(basename "${SHELL-}")" = ash ] && maxnjobs=1

# Be quiet?
quiet=

# Search static code analysers?
statenable=

# Flags needed for testing compiler features.
testflags='-std=c99 -Wextra -Wpedantic -pedantic -pipe'

# Conversion warning flags.
wconvflags='-Wincompatible-pointer-types -Wconversion -Wsign-conversion'


#
# Initialisation
#

set -Ceu
src_dir="$(dirname "$0")" || exit
readonly src_dir
cd "$src_dir" || exit
. ./scripts/funcs.sh || exit
init
tmpdir tmp .


#
# Constants
#

# Variables to set as M4 Macros.
readonly macros='
	CC CFLAGS AR ARFLAGS LDFLAGS LDLIBS DESTDIR PREFIX
	SUCGI_GRP_T SUCGI_NGRPS_T SUCGI_MAX_UID_VAL SUCGI_MAX_GID_VAL
	SUCGI_MAX_GRP_VAL SUCGI_MAX_NGRPS_VAL SUCGI_HAVE_SYS_PARAM_H
	SUCGI_HAVE_FEATURES_H SUCGI_UNAME SUCGI_SHARED SUCGI_CGI_DIR
	SUCGI_WWW_GRP
'

# Where to save the configuration.
readonly confsave=config.status

# Integer types that may be used for IDs and sizes. Colon-separated list.
inttypes=''
for base in 'int' 'long' 'long long'
do
	for prefix in '' 'unsigned '
	do inttypes="$inttypes:$prefix$base"
	done
done
inttypes="$inttypes:intmax_t:uintmax_t"
unset base
readonly inttypes

# Possible data types for group IDs. Colon-separated list.
readonly grouptypes="gid_t:$inttypes"

# Possible data types for sizes. Colon-separated list.
readonly sizetypes="size_t:$inttypes"


#
# Functions
#

# Check if the given compiler supports the given flags.
addflags() {
	__addflags_ncomps=0 __addflags_comps=
	for __addflags_arg
	do
		case $__addflags_arg in (-*)
			break
		esac

		__addflags_ncomps=$((__addflags_ncomps + 1))
		__addflags_comps="$__addflags_comps $__addflags_arg"
	done

	if [ "$__addflags_ncomps" -gt 0 ]
	then
		shift "$__addflags_ncomps"
		for __addflags_comp in $__addflags_comps
		do
			__addflags_var="cflags_${__addflags_comp}"
			eval "$__addflags_var=\"\${$__addflags_var-} \$*\""
		done
	else
		cflags="${cflags-} $*"
	fi

	unset __addflags_arg __addflags_ncomps __addflags_comps \
	      __addflags_comp __addflags_var
}

# Test compilation.
testcc() (
	: "${testcc_cc:?}" "${testcc_cflags?}"

	exec >/dev/null 2>&1

	case $testcc_cc in
	(clang|gcc)
		# shellcheck disable=2086
		"$CC" -xc -Wall -Werror $testcc_cflags -o/dev/null "$@"
		;;
	(tcc)
		# TinyCC unlinks /dev/null when given -o/dev/null.
		# https://savannah.nongnu.org/bugs/index.php?64476
		# shellcheck disable=2086
		"$CC" -Wunsupported \
		      -xc -Wall -Werror $testcc_cflags -o"$TMPDIR/a.out" "$@"
		;;
	(icc)
		# shellcheck disable=2086
		"$CC" -diag-enable=10006,10148 -diag-error=10006,10148 \
		      -xc -Wall -Werror $testcc_cflags -o/dev/null "$@"
		;;
	(*)
		return 1
		;;
	esac
)

# Test compiler flags.
testflags() {
	testcc "$@" - <<-'EOF'
	int
	main(void) {
		return 0;
	}
	EOF
}


#
# Options
#

OPTIND=1 OPTARG='' opt=''
while getopts F:D:U:Xc:dfhj:p:qs opt
do
	# shellcheck disable=2154
	case $opt in
	(h) exec cat <<EOF >&2
configure - generate a build configuration

Usage:    configure [-F FLAG] [-D|-U MACRO ...]
                    [-cFILE|-d] [-f] [-jN] [-q] [FILE ...]
          configure -h

Operands:
    FILE  A file to generate (default: $files).

Options:
    -F FLAG   Add FLAG to \$CFLAGS if supported by the compiler.
    -D MACRO  Short for "-F -DMACRO".
    -U MACRO  Short for "-F -UMACRO".
    -c FILE   Read build configuration from FILE (default: $conf).
    -d        Short for "-c conf/devel.env".
    -f        Overwrite existing files.
    -j N      Run at most N tests in parallel (default: $maxnjobs).
    -q        Be quiet.
    -h        Show this help screen.

See docs/build.rst for details.

Copyright 2022 and 2023 Odin Kroeger.
Released under the GNU Affero General Public License.
This programme comes with ABSOLUTELY NO WARRANTY.
EOF
	    ;;
	(X) set -x ;;
	(D) addflags "-D$OPTARG" ;;
	(U) addflags "-U$OPTARG" ;;
	(F) addflags "$OPTARG" ;;
	(c) conf="$OPTARG" ;;
	(d) conf=conf/devel.env ;;
	(f) force=y ;;
	(j) maxnjobs="$OPTARG" ;;
	(q) quiet=y ;;
	(*) exit 1
	esac
done
shift $((OPTIND - 1))
unset opt

[ "$conf" ]	|| err '-c: no filename given.'
[ -e "$conf" ]	|| err '%s: no such file.' "$conf"

# shellcheck disable=1090
case $conf in ([!/.]*)
	conf="./$conf"
esac

# shellcheck source=devel.conf
. "$conf" || exit
unset conf

if [ "$prog_name" = "$confsave" ]
then
	exec >/dev/null
	force=y
fi

# shellcheck disable=2086
[ $# -eq 0 ] && set -- $files
unset files

nfiles=0
for file
do
	eval "file_$nfiles"='"$file"'
	nfiles=$((nfiles + 1))
done
shift $#

# shellcheck disable=2034
readonly force quiet maxnjobs nfiles


#
# System.
#

printf 'System: '

: "${SUCGI_UNAME:="$(uname)"}"

printf '%s\n' "$SUCGI_UNAME"


#
# Check which compiler is available.
#

printf 'C compiler: '

: "${CC:=}"
if ! [ "$CC" ]
then
	for cc in $compilers
	do
		if	command -v "$cc" >/dev/null 2>&1 &&
			"$cc" -v 2>&1 | grep -q "$cc"
		then
			CC="$cc"
			break
		fi
	done

	if ! [ "$CC" ]
	then
		for cc in c99 cc
		do
			if command -v "$cc" >/dev/null 2>&1
			then
				CC="$cc"
				break
			fi
		done
	fi

	unset cc
fi

if ! [ "$CC" ]
then
	printf 'none found\a\n'
	exit 2
fi

# Compiler path.
set -- "$CC"
ccpath="${1:?}"
readonly ccpath

# Compiler executable.
ccexec="$(basename "${ccpath:?}")"
readonly ccexec

# Compiler name.
case $ccexec in
(musl-*) ccname="${ccexec##musl-}"
esac
ccname="${ccexec%%[!a-z]*}"
readonly ccname

# Compiler command prefix.
case $ccname in
(clang)	ccpre=llvm ;;
(*)	ccpre="$ccname" ;;
esac
readonly ccpre

# Compiler flags useful for testing compiler features.
testcc_cc="$ccname"
testcc_cflags=
# shellcheck disable=2086
for flag in $testflags
do testflags $flag && testcc_cflags="$testcc_cflags $flag"
done
unset flag
readonly testcc_cc testcc_cflags

# Output.
printf '%s\n' "$CC"


#
# Check which flags the C compiler supports.
#

printf 'Compiler flags:'

if [ "${CFLAGS-x}" = x ] && ! [ "${CFLAGS-}" = x ]
then
	if [ "$ccname" = c99 ]
	then
		CFLAGS="-O1 -s"
		printf ' %s\n' "$CFLAGS"
	else
		eval specflags="\${cflags_$ccname-}"

		# shellcheck disable=2086,SC2154
		set -- $cflags $specflags
		njobs=0 jobs=''
		while [ "$njobs" -gt 0 ] || [ $# -gt 0 ]
		do
			# Start jobs.
			while [ "$njobs" -lt "$maxnjobs" ] && [ $# -gt 0 ]
			do
				flag="$1"
				shift

				case $flag in (-D*)
					CFLAGS="${CFLAGS-} $flag"
					continue
				esac

				testflags "$flag" &

				njobs=$((njobs + 1)) jobs="$jobs$! "
				eval "flag_$!"='$flag'
				unset flag
			done

			# Collect the job on top of the pile.
			job="${jobs%% *}"
			if wait "$job"
			then
				eval flag="\"\${flag_$job-}\""
				unset "flag_$job"
				CFLAGS="${CFLAGS-} $flag"
				printf -- ' %s' "$flag"
			fi
			njobs=$((njobs - 1)) jobs="${jobs#* }"
			unset job
		done

		[ "${CFLAGS-}" ] || printf ' none detected'

		echo
		unset jobs specflags
	fi
else
	printf -- ' %s\a\n' "${CFLAGS:-none given}"
fi
unset cflags


#
# Check whether the compiler supports -shared.
#

printf 'Shared object flag: '

if [ "${SUCGI_SHARED-x}" = x ] && [ "${SUCGI_SHARED-}" != x ]
then
	SUCGI_SHARED=
	for flag in -dynamiclib -shared
	do
		if testflags "$flag" -fpic
		then
			SUCGI_SHARED="$flag"
			break
		fi
	done
fi

if [ "$SUCGI_SHARED" ]
then printf '%s\n' "$SUCGI_SHARED"
else printf 'unsupported\n'
fi


#
# Check which archiver to use.
#

printf 'Archiver: '

if [ "${AR-x}" = x ] && ! [ "${AR-}" = x ]
then
	ccvers="$(
		"$CC" -v 2>&1 |
		awk '{
			for (i = 1; i <= NF; i++) {
				if ($i ~ /^v?[0-9]+\.[0-9]+\./) {
					gsub("[^0-9\.]", "", $i);
					print $i;
					exit;
				}
			}
		}' 2>/dev/null
	)"

	if [ "$ccvers" ]
	then
		ccmajor="${ccvers%%.*}"
	else
		case $ccexec in
		(*[0-9]*) ccmajor="${ccexec#${ccexec%%[0-9]*}}" ;;
		(*)       ccmajor= ;;
		esac
	fi
	readonly ccvers ccmajor

	if [ "${ccmajor-}" ]
	then archivers="$ccpre-ar-$ccmajor $ccpre-ar$ccmajor $ccpre-ar"
	else archivers="$ccpre-ar"
	fi

	for archiver in $archivers
	do
		if command -v "$archiver" >/dev/null 2>&1
		then
			AR="$archiver"
			break
		fi
	done
fi

printf '%s\n' "${AR-default}"


#
# Check which headers are available.
#

printf 'Headers:'

# shellcheck disable=2086,SC2154
set -- $headers
nheaders=0 njobs=0 jobs=''
while [ "$njobs" -gt 0 ] || [ $# -gt 0 ]
do
	# Start jobs.
	while [ "$njobs" -lt "$maxnjobs" ] && [ $# -gt 0 ]
	do
		header="$1"
		shift

		headervar="SUCGI_HAVE_$(
			printf '%s\n' "$header"	|
			sed 's/[^a-z]/_/g'	|
			tr '[:lower:]' '[:upper:]'
		)"

		case $headervar in (SUCGI_HAVE_|*[!A-Z0-9_]*)
			warn '%s: could not derive macro name.'
			continue
		esac

		eval headeravail="\${$headervar-}"

		# shellcheck disable=2154
		case $headeravail in
		(0)
			eval "$headervar=0"
			;;
		(1)
			eval "$headervar=1"
			nheaders=$((nheaders + 1))
			printf ' %s' "$header"
			;;
		(*)
			"$CC" -xc -E - <<-EOF >/dev/null 2>&1 &
			#include <$header>
			EOF

			njobs=$((njobs + 1)) jobs="$jobs$! "
			eval "header_$!"='$header'
			eval "headervar_$!"='$headervar'
		esac

		unset header headervar headeravail
	done

	# Collect the job on top of the pile.
	if [ "$njobs" -gt 0 ]
	then
		job="${jobs%% *}"
		eval header="\"\${header_$job-}\""
		eval headervar="\"\${headervar_$job-}\""
		unset "header_$job" "headervar_$job"

		if wait "$job"
		then
			eval "$headervar=1"
			nheaders=$((nheaders + 1))
			printf -- ' %s' "$header"
		else
			eval "$headervar=0"
		fi

		njobs=$((njobs - 1)) jobs="${jobs#* }"
		unset header headervar job
	fi
done

case $nheaders in
(0) printf ' none found\n' ;;
(*) printf '\n' ;;
esac


# #
# # Check which libraries are available
# #
#
# printf 'Libraries:'
#
#
# # shellcheck disable=2086,SC2154
# set -- $libs
# nlibs=0 njobs=0 jobs=''
# while [ "$njobs" -gt 0 ] || [ $# -gt 0 ]
# do
# 	# Start jobs.
# 	while [ "$njobs" -lt "$maxnjobs" ] && [ $# -gt 0 ]
# 	do
# 		lib="$1"
# 		shift
#
# 		libvar="SUCGI_HAVE_LIB$(
# 			printf '%s\n' "$lib"	|
# 			sed 's/[^a-z]/_/g'	|
# 			tr '[:lower:]' '[:upper:]'
# 		)"
#
# 		case $libvar in (SUCGI_HAVE_LIB_|*[!A-Z0-9_]*)
# 			warn '%s: could not derive macro name.'
# 			continue
# 		esac
#
# 		eval libavail="\${$libvar-}"
#
# 		# shellcheck disable=2154
# 		case $libavail in
# 		(0)
# 			eval "$libvar=0"
# 			;;
# 		(1)
# 			eval "$libvar=1"
# 			nlibs=$((nlibs + 1))
# 			printf ' %s' "$lib"
# 			;;
# 		(*)
# 			src="$TMPDIR/lib.c"
# 			printf 'int main(void) {return 0;}\n' >"$src"
#
# 			"$CC" -o"${src%.c}.out" "$src" -l"$lib" 2>/dev/null &
# 			njobs=$((njobs + 1)) jobs="$jobs$! "
# 			eval "lib_$!"='$lib'
# 			eval "libvar_$!"='$libvar'
# 		esac
#
# 		unset lib libvar libavail
# 	done
#
# 	# Collect the job on top of the pile.
# 	if [ "$njobs" -gt 0 ]
# 	then
# 		job="${jobs%% *}"
# 		eval lib="\"\${lib_$job-}\""
# 		eval libvar="\"\${libvar_$job-}\""
# 		unset "lib_$job" "libvar_$job"
#
# 		if wait "$job"
# 		then
# 			eval "$libvar=1"
# 			LDLIBS="${LDLIBS-} -l$lib" nlibs=$((nlibs + 1))
# 			printf -- ' %s' "$lib"
# 		else
# 			eval "$libvar=0"
# 		fi
#
# 		njobs=$((njobs - 1)) jobs="${jobs#* }"
# 		unset lib libvar job
# 	fi
# done
#
# case $nlibs in
# (0) printf ' none found\n' ;;
# (*) printf '\n' ;;
# esac
#
#
# #
# # How to validate accounts
# #
#
# printf 'Account validation: '
#
# if	[ "${SUCGI_HAVE_SECURITY_PAM_APPL_H-0}" -ne 0 ] &&
# 	[ "${SUCGI_HAVE_LIBPAM-0}" -ne 0 ]
# then
# 	printf 'PAM\n'
# elif	[ "${SUCGI_HAVE_SHADOW-0}" -ne 0 ]
# then
# 	printf 'shadow\n'
# else
# 	if ! [ "${SUCGI_HAVE_EXPIRE-}" ]
# 	then
# 		src="$TMPDIR/pw_expire.c"
# 		cat <<-'EOF' >"$src"
# 			#define _BSD_SOURCE
# 			#define _DARWIN_C_SOURCE
# 			#define _DEFAULT_SOURCE
# 			#define _GNU_SOURCE
#
# 			#include <sys/types.h>
# 			#include <pwd.h>
#
# 			struct passwd pwd = {.pw_expire = 0};
# 		EOF
#
# 		if "$CC" -c -o"$TMPDIR/pw_expire.o" "$src" >/dev/null 2>&1
# 		then SUCGI_HAVE_EXPIRE=1
# 		else SUCGI_HAVE_EXPIRE=0
# 		fi
# 	fi
#
# 	case ${SUCGI_HAVE_EXPIRE-0} in
# 	(0) printf 'not supported\n' ;;
# 	(*) printf 'passwd\n' ;;
# 	esac
# fi


#
# Check what data type getgrouplist returns GIDs as.
#

printf 'getgrouplist GID type: '

: "${SUCGI_GRP_T=}"
# shellcheck disable=2086
if ! [ "$SUCGI_GRP_T" ] && testflags $wconvflags
then
	IFS=:
	for grouptype in $grouptypes
	do
		unset IFS || :
		[ "$grouptype" ] || continue

		# shellcheck disable=2086
		if	testcc $wconvflags -DGRP_T="$grouptype" - <<-'EOF'
			#define _BSD_SOURCE
			#define _DARWIN_C_SOURCE
			#define _DEFAULT_SOURCE
			#define _GNU_SOURCE

			#include <grp.h>
			#include <inttypes.h>
			#include <unistd.h>

			int
			main(void)
			{
				GRP_T basegid = 0;
				GRP_T groups[1] = {0};
				int n = 1;

				getgrouplist("dummy", basegid, groups, &n);

				return 0;
			}
			EOF
		then
			SUCGI_GRP_T="$grouptype"

			break
		fi
	done
	unset grouptype
fi

case $SUCGI_GRP_T in
("short")              SUCGI_MAX_GRP_VAL=SHRT_MAX ;;
("unsigned short")     SUCGI_MAX_GRP_VAL=USHRT_MAX ;;
("int")                SUCGI_MAX_GRP_VAL=INT_MAX ;;
("unsigned int")       SUCGI_MAX_GRP_VAL=UINT_MAX ;;
("long")               SUCGI_MAX_GRP_VAL=LONG_MAX ;;
("unsigned long")      SUCGI_MAX_GRP_VAL=ULONG_MAX ;;
("long long")          SUCGI_MAX_GRP_VAL=LLONG_MAX ;;
("unsigned long long") SUCGI_MAX_GRP_VAL=ULLONG_MAX ;;
("intmax_t")           SUCGI_MAX_GRP_VAL=INTMAX_MAX ;;
("uintmax_t")          SUCGI_MAX_GRP_VAL=UINTMAX_MAX ;;
("gid_t")              SUCGI_MAX_GRP=MAX_GID_VAL
esac

if [ "$SUCGI_GRP_T" ]
then printf '%s\n' "$SUCGI_GRP_T"
else printf 'guess at compile-time\n'
fi


#
# Check what data type setgroups takes the group size as.
#

printf 'setgroups count type: '

: "${SUCGI_NGRPS_T=}"
# shellcheck disable=2086
if ! [ "$SUCGI_NGRPS_T" ] && testflags $wconvflags
then
	IFS=:
	for sizetype in $sizetypes
	do
		unset IFS || :
		[ "$sizetype" ] || continue

		# shellcheck disable=2086
		if	testcc $wconvflags -DNGRPS_T="$sizetype" - <<-'EOF'
			#define _BSD_SOURCE
			#define _DARWIN_C_SOURCE
			#define _DEFAULT_SOURCE
			#define _GNU_SOURCE

			#include <sys/types.h>
			#include <grp.h>
			#include <unistd.h>

			int
			main(void)
			{
				NGRPS_T ngroups = 0;
				gid_t gidset[1] = {0};

				(void) setgroups(ngroups, gidset);

				return 0;
			}
			EOF
		then
			SUCGI_NGRPS_T="$sizetype"
			break
		fi
	done
	unset sizetype
fi

case $SUCGI_NGRPS_T in
("short")              SUCGI_MAX_NGRPS_VAL=SHRT_MAX ;;
("unsigned short")     SUCGI_MAX_NGRPS_VAL=USHRT_MAX ;;
("int")                SUCGI_MAX_NGRPS_VAL=INT_MAX ;;
("unsigned int")       SUCGI_MAX_NGRPS_VAL=UINT_MAX ;;
("long")               SUCGI_MAX_NGRPS_VAL=LONG_MAX ;;
("unsigned long")      SUCGI_MAX_NGRPS_VAL=ULONG_MAX ;;
("long long")          SUCGI_MAX_NGRPS_VAL=LLONG_MAX ;;
("unsigned long long") SUCGI_MAX_NGRPS_VAL=ULLONG_MAX ;;
("intmax_t")           SUCGI_MAX_NGRPS_VAL=INTMAX_MAX ;;
("uintmax_t")          SUCGI_MAX_NGRPS_VAL=UINTMAX_MAX ;;
esac

if [ "$SUCGI_NGRPS_T" ]
then printf '%s\n' "$SUCGI_NGRPS_T"
else printf 'guess at compile-time\n'
fi


#
# Calculate the maximum values representable as uid_t and gid_t.
#

for idtype in uid_t gid_t
do
	printf '%s maximum: ' "$idtype"

	if testflags $wconvflags
	then
		idmax=
		for maxval in                  \
			UINTMAX_MAX INTMAX_MAX \
			ULLONG_MAX  LLONG_MAX  \
			ULONG_MAX   LONG_MAX   \
			UINT_MAX    INT_MAX    \
			USHRT_MAX   SHRT_MAX
		do
			# shellcheck disable=2086
			if	testcc $wconvflags \
				       -D"T=$idtype" -D"V=$maxval" - <<-'EOF'
				#include <sys/types.h>
				#include <inttypes.h>
				#include <limits.h>
				#include <stdio.h>

				int
				main(void)
				{
					T var = V;

					/* Variable must be used. */
					printf("%ju\n", (uintmax_t) var);

					return 0;
				}
				EOF
			then
				idmax="$maxval"
				break
			fi
		done
	fi

	if [ "$idmax" ]
	then
		case $idtype in
		(uid_t) SUCGI_MAX_UID_VAL="$maxval" ;;
		(gid_t) SUCGI_MAX_GID_VAL="$maxval" ;;
		(*)     err -s78 '%s: unknown type.' "$idtype"
		esac

		printf '%s\n' "$maxval"
	else
		printf 'guess at compile-time\n'
	fi

	unset idmax idtype maxccal
done


#
# Generate M4 command line.
#

shift $#
for key in $macros
do
	eval "value=\"\${$key-}\""
	if [ "$value" ]
	then
		case $# in
		(0) set -- "-D__${key}=\`${value# }'" ;;
		(*) set -- "$@" "-D__${key}=\`${value# }'" ;;
		esac
	fi
done
unset key value


#
# Save configuration.
#

if [ -e "$confsave" ]
	then exists=x
	else exists=
fi

if [ "$prog_name" != "$confsave" ]
then
	if [ "$exists" ] && ! [ "$force" ]
	then
		err '%s exists, give -f to overwrite.' "$confsave"
	else
		swap="$TMPDIR/$confsave"

		cat <<-'EOF' >"$swap"
		#!/bin/sh
		# Last configuration detected by ./configure.

		EOF

		for key in $macros
		do
			eval "value=\"\${$key--}\""
			[ "$value" = - ] && continue
			# shellcheck disable=2016
			printf ': "${%s="%s"}"\n' "$key" "${value# }" >>"$swap"
		done
		unset key value

		cat <<-'EOF' >>"$swap"

		. ./configure
		EOF

		chmod +x "$swap"

		if [ "$exists" ]
		then
			if cmp "$swap" "$confsave" >/dev/null 2>&1
			then
				warn -q 'no changes to %s.' "$confsave"
			else
				warn -q 'updating %s ...' "$confsave"
				mv -f "$swap" "$confsave"
			fi
		else
			warn -q 'creating %s ...' "$confsave"
			mv -f "$swap" "$confsave"
		fi
	fi
fi


#
# Create files.
#

i=0
while [ "$i" -lt "$nfiles" ]
do
	eval file="\${file_$i}"
	template="$file.m4" i=$((i + 1))

	exists=
	# shellcheck disable=2154
	if [ -e "$file" ]
	then
		exists=x
		if ! [ "$force" ]
		then
			warn '%s exists.' "$file"
			continue
		fi
	fi

	swap="$TMPDIR/$file"
	if m4 "$@" "$template" >"$swap"
	then
		if [ "$exists" ]
		then
			if cmp "$swap" "$file" >/dev/null 2>&1
			then
				warn -q 'no changes to %s.' "$file"
				continue
			else
				warn -q 'updating %s ...' "$file"
			fi
		else
			warn -q 'creating %s ...' "$file"
		fi

		mv -f "$swap" "$file"
	else
		rm -f "$swap" || :
		err 'could not generate %s.' "$file"
	fi
	unset swap
done
