#!/bin/sh
# Generate a build configuration.
#
# Copyright 2022 and 2023 Odin Kroeger.
#
# This file is part of suCGI.
#
# suCGI is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option)
# any later version.
#
# suCGI is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
# for more details.
#
# You should have received a copy of the GNU General Public License along
# with suCGI. If not, see <https://www.gnu.org/licenses>.

# shellcheck disable=1091,2015

#
# Initialisation
#

set -Ceu

src_dir="$(dirname "$0")" || exit
readonly src_dir
cd "$src_dir" || exit
. ./tools/lib.sh || exit
init
tmpdir tmp .


#
# Constants
#

# Number of child processes to spawn.
readonly max_njobs=4

# Variables to set as M4 Macros.
readonly macros='
	CC CFLAGS AR ARFLAGS LDFLAGS LDLIBS DESTDIR PREFIX
	SC_GETGRPLST_T SC_SETGRPNUM_T SC_COV_CC SC_CGI_DIR SC_WWW_GRP
	sc_repo_owner
'

readonly confsave=config.status


#
# Defaults
#

# Default build configuration.
conf=prod.env

# Overwrite existing files?
force=

# Be quiet?
quiet=


#
# Functions
#

# Check if the compiler supports the given flags.
# If $1 does not start with a dash, assume it's the basename of a compiler
# and only check if the compiler's basename matches.
addflags() {
	case ${1:?} in
	(-*) cflags="${cflags-} $*" ;;
	(*)  eval "cflags_$1"="\"\${cflags_$1-} \${*#* }\"" ;;
	esac
}

# Test compiler features.
testcc() {
	case "$(basename "${CC:?}")" in
	(clang|clang[!a-z]*|gcc|gcc[!a-z]*|musl-gcc|musl-gcc[!a-z]*)
		"$CC" -xc -Wall -Werror -pedantic -o/dev/null "$@"
		;;
	(icc|icc[!a-z]*)
		"$CC" -xc -w3 -Wcheck -Werror-all -o/dev/null "$@"
		;;
	(*)
		return 1
		;;
	esac
}


#
# Options
#

OPTIND=1 OPTARG='' opt=''
while getopts Dc:dfqh opt; do
	# shellcheck disable=2154
	case $opt in
	(h) exec cat <<EOF >&2
$prog_name - generate a build configuration

Usage:       $prog_name [-cFILE|-d] [-f] [-q] [FILE ...]
             $prog_name -h

Operands:
    FILE     A file to generate (default: all files).

Options:
    -c FILE  Read build configuration from FILE (default: $conf).
    -d       Short for -c devel.env.
    -f       Overwrite existing files. config.h is never overwritten.
    -q       Be quiet.
    -h       Show this help screen.

See docs/build.rst for details.

Copyright 2022 and 2023 Odin Kroeger.
Released under the GNU General Public License.
This programme comes with ABSOLUTELY NO WARRANTY.
EOF
		;;
	(D) set -x ;;
	(c) conf="$OPTARG" ;;
	(d) conf=devel.env ;;
	(f) force=x ;;
	(q) quiet=x ;;
	(*) exit 1
	esac
done
shift $((OPTIND - 1))
unset opt

[ "$conf" ]	|| err '-c: no filename given.'
[ -e "$conf" ]	|| err '%s: no such file.' "$conf"

# shellcheck disable=1090
case $conf in ([!/.]*)
	conf="./$conf"
esac

# shellcheck source=devel.conf
. "$conf" || exit

if [ $# -eq 0 ]
then
	set -- *.m4
	[ "$*" = "*.m4" ] && shift $#
fi

nfiles=0
for file
do
	case $file in (*.m4)
		file="${file%.m4}"
	esac

	eval "file_$nfiles"='"$file"'
	nfiles=$((nfiles + 1))
done
shift $#

if [ "$prog_name" = "$confsave" ]
then
	exec >/dev/null
	force=x
fi

# shellcheck disable=2034
readonly conf force quiet nfiles


#
# Check if gcc, clang, or icc are available.
#

printf 'C compiler: '

: "${CC:=}"
if ! [ "$CC" ]
then
	for cc in gcc clang icc
	do
		if	command -v "$cc" >/dev/null &&
			"$cc" -v 2>&1 | grep -q "$cc"
		then
			CC="$cc"
			break
		fi
	done

	if ! [ "$CC" ]
	then
		for cc in c99 cc
		do
			if command -v "$cc" >/dev/null
			then
				CC="$cc"
				break
			fi
		done
	fi

	unset cc
fi

if [ "$CC" ]
then
	printf '%s\n' "$CC"
else
	printf 'none found.\a\n'
	exit 2
fi

ccname="$(basename "$CC")"
if [ "$ccname" = c99 ]
	then cctype="$ccname"
	else cctype="${ccname%%[!a-z]*}"
fi


#
# Check which flags the C compiler supports.
#

printf 'Compiler flags:'

if [ "${CFLAGS-x}" = x ] && ! [ "${CFLAGS-}" = x ]
then
	if [ "$ccname" = c99 ]
	then
		CFLAGS="-O2 -s"
		printf ' %s\n' "$CFLAGS"
	else
		eval specflags="\${cflags_$cctype-}"

		# shellcheck disable=2086,SC2154
		set -- $cflags $specflags
		njobs=0 jobs=''
		while [ "$njobs" -gt 0 ] || [ $# -gt 0 ]
		do
			# Start jobs.
			while [ "$njobs" -lt "$max_njobs" ] && [ $# -gt 0 ]
			do
				flag="$1"
				shift

				case $flag in (-D*)
					CFLAGS="${CFLAGS-} $flag"
					continue
				esac
				printf 'int main(void) { return 0; }\n' |
					testcc "$flag" - >/dev/null 2>&1 &
				njobs=$((njobs + 1)) jobs="$jobs$! "
				eval "flag_$!"='$flag'
			done

			# Collect the job on top of the pile.
			job="${jobs%% *}"
			if wait "$job"
			then
				eval flag="\"\${flag_$job-}\""
				unset "flag_$job"
				CFLAGS="${CFLAGS-} $flag"
				printf -- ' %s' "$flag"
			fi
			njobs=$((njobs - 1)) jobs="${jobs#* }"
			unset job
		done

		[ "${CFLAGS-}" ] || printf ' none supported.\a'
		echo
	fi
else
	printf -- ' %s\a\n' "${CFLAGS:-none given.}"
fi
unset cflags flag jobs job


#
# Check which archiver to use.
#

printf 'Archiver: '

if [ "${AR-x}" = x ] && ! [ "${AR-}" = x ]
then
	[ "$cctype" = clang ] && cctype=llvm

	if ccversion="$(
		"$CC" --version |
		awk '{
			for (i = 1; i <= NF; i++) {
				if ($i ~ /^v?[0-9]+\.[0-9]+\./) {
					print $i;
					exit;
				}
			}
		}'
	)"
	then
		ccversion="${ccversion#v}"
		ccmajor="${ccversion%%.*}"
	else
		ccmajor="${ccname#$cctype-}"
	fi

	archivers="$cctype-ar"
	[ "$cctype" != "$ccname" ] &&
		archivers="$ccname-ar $archivers"
	[ "${ccmajor-}" ] &&
		archivers="$cctype-ar-$ccmajor $cctype-$ccmajor-ar $archivers"

	for ar in $archivers
	do
		if command -v "$ar" >/dev/null 2>&1
		then
			AR="$ar"
			break
		fi
	done

	printf '%s\n' "${AR-default}"
fi


#
# Check what data type getgrouplist returns GIDs as.
#

printf 'getgrouplist group ID type: '

: "${SC_GETGRPLST_T=}"
if ! [ "$SC_GETGRPLST_T" ]
then
	types=gid_t
	for base in 'int' 'short' 'long' 'long long'
	do
		for prefix in '' 'unsigned '
		do
			types="$types:$prefix$base"
		done
	done

	src="$TMPDIR/getgrouplist.c"
	cat <<-'EOF' >"$src"
		#define _BSD_SOURCE
		#define _DARWIN_C_SOURCE
		#define _DEFAULT_SOURCE
		#define _GNU_SOURCE

		#include <grp.h>
		#include <unistd.h>

		int
		main(void) {
			GETGRPLST_T basegid = 0;
			GETGRPLST_T groups[1] = {0};
			int n = 1;

			getgrouplist("dummy", basegid, groups, &n);

			return 0;
		}
	EOF

	IFS=:
	for type in $types
	do
		if testcc -DGETGRPLST_T="$type" "$src" >/dev/null 2>&1
		then
			SC_GETGRPLST_T="$type"
			break
		fi
	done
	unset IFS src

	if [ "${SC_GETGRPLST_T-}" ]
	then
		printf '%s\n' "$SC_GETGRPLST_T"
	else
		printf 'guess at compile-time\a\n'
	fi
else
	printf '%s\n' "$SC_GETGRPLST_T"
fi


#
# Check what type setgroups takes the groups size as.
#

printf 'setgroups count type: '

: "${SC_SETGRPNUM_T=}"
if	! [ "$SC_SETGRPNUM_T" ] &&
	printf 'int main(void) { return 0; }\n' | testcc -Wconversion -
then
	types=size_t
	for base in 'int' 'short' 'long' 'long long'
	do
		for prefix in '' 'unsigned '
		do
			types="$types:$prefix$base"
		done
	done

	src="$TMPDIR/setgroups.c"
	cat <<-'EOF' >"$src"
		#define _BSD_SOURCE
		#define _DARWIN_C_SOURCE
		#define _DEFAULT_SOURCE
		#define _GNU_SOURCE

		#include <sys/types.h>
		#include <grp.h>
		#include <unistd.h>

		int
		main(void) {
			SETGRPNUM_T ngroups = 0;
			gid_t gidset[1] = {0};

			(void) setgroups(ngroups, gidset);

			return 0;
		}
	EOF

	IFS=:
	for type in $types
	do
		if testcc -DSETGRPNUM_T="$type" -Wconversion "$src" >/dev/null 2>&1
		then
			SC_SETGRPNUM_T="$type"
			break
		fi
	done

	unset IFS src
fi

if [ "${SC_SETGRPNUM_T-}" ]
	then printf '%s\n' "$SC_SETGRPNUM_T"
	else printf 'guess at compile-time\a\n'
fi


#
# Check who owns the repository.
#

# TODO: If the repository is owned by root,
#       coverage reports will either fail or be inaccurate.
#       Think of a better solution.
# shellcheck disable=2034
sc_repo_owner=$(owner "$src_dir") || sc_repo_owner="$(id -un)"


#
# Generate M4 command line.
#

set --
for key in $macros
do
	eval "value=\"\${$key-}\""
	[ "$value" ] && set -- "$@" "-D__${key}__=${value# }"
done
unset key value


#
# Save configuration.
#

if [ -e "$confsave" ]
	then exists=x
	else exists=
fi

if [ "$prog_name" != "$confsave" ]
then
	if [ "$exists" ] && ! [ "$force" ]
	then
		warn -q '%s exists.' "$confsave"
	else
		swap="$TMPDIR/$confsave"

		cat <<-'EOF' >"$swap"
		#!/bin/sh
		# Last configuration detected by ./configure.

		EOF

		for key in $macros
		do
			eval "value=\"\${$key--}\""
			[ "$value" = - ] && continue
			# shellcheck disable=2016
			printf ': "${%s="%s"}"\n' "$key" "${value# }" >>"$swap"
		done
		unset key value

		printf '\n. ./configure\n' >>"$swap"

		chmod +x "$swap"

		mv "$swap" "$confsave"

		if [ "$exists" ]
			then warn -q 'updated %s.' "$confsave"
			else warn -q 'saved configuration in %s.' "$confsave"
		fi
	fi
fi

#
# Create files.
#

i=0
while [ "$i" -lt "$nfiles" ]
do
	eval file="\${file_$i}"
	template="$file.m4" i=$((i + 1))

	exists=
	# shellcheck disable=2154
	if [ -e "$file" ]
	then
		exists=x
		if ! [ "$force" ]
		then
			warn '%s exists.' "$file"
			continue
		fi
	fi

	swap="$TMPDIR/$file"
	if m4 "$@" "$template" >"$swap"
	then
		mv "$swap" "$file"
		if [ "$exists" ]
			then warn -q 'updated %s.' "$file"
			else warn -q 'generated %s.' "$file"
		fi
	else
		rm -f "$swap" || :
		err 'could not generate %s.' "$file"
	fi
	unset swap
done

