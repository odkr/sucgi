#!/bin/sh
# Generate a build configuration.
#
# Copyright 2022 and 2023 Odin Kroeger.
#
# This file is part of suCGI.
#
# suCGI is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option)
# any later version.
#
# suCGI is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
# for more details.
#
# You should have received a copy of the GNU General Public License along
# with suCGI. If not, see <https://www.gnu.org/licenses>.

# shellcheck disable=1091,2015

#
# Initialisation
#

set -Ceu

src_dir="$(dirname "$0")" || exit
readonly src_dir
cd "$src_dir" || exit
. ./scripts/funcs.sh || exit
init
tmpdir conf .


#
# Constants
#

# Variables to set as M4 Macros.
readonly macros='
	CC CFLAGS AR ARFLAGS LDFLAGS LDLIBS DESTDIR PREFIX
	SC_GETGRPLST_T SC_SETGRPNUM_T SC_CGI_DIR SC_WWW_GRP
	machine os osvers compvers compmajor
'

readonly confsave=config.status


#
# Defaults
#

# Build configuration.
conf=prod.env

# Compilers to test for. Space-separated list of commands.
compilers='gcc clang tcc icc'

# Files to generate.
files='build.h compat.h makefile'

# Number of child processes to spawn.
maxnjobs=4
# FIXME: The Almquist shell may crash when using multiple jobs.
[ "$(basename "${SHELL-}")" = ash ] && maxnjobs=1

# Overwrite existing files?
force=

# Be quiet?
quiet=


#
# Functions
#

# Check if the given compiler supports the given flags.
addflags() {
	case ${1:?} in
	(-*) cflags="${cflags-} $*" ;;
	(*)  eval "cflags_$1"="\"\${cflags_$1-} \$*\"" ;;
	esac
}

# Test compiler flags.
testflags() (
	exec >/dev/null 2>&1

	case "$(basename "${CC:?}")" in
	(clang|clang-*|musl-clang|musl-clang-*|gcc|gcc-*|musl-gcc|musl-gcc-*)
		"$CC" -xc -Wall -Werror -E "$@" /dev/null
		;;
	(tcc|tcc-*)
		"$CC" -xc -Wall -Wunsupported -Werror -E "$@" /dev/null
		;;
	(icc|icc-*)
		"$CC" -diag-enable=10006,10148 -diag-error=10006,10148 \
		      -xc -Wcheck -Werror-all -E "$@" /dev/null
		;;
	(*)
		return 1
		;;
	esac
)

# Test compilation.
testcomp() (
	exec >/dev/null 2>&1

	case "$(basename "${CC:?}")" in
	(clang|clang-*|musl-clang|musl-clang-*|gcc|gcc-*|musl-gcc|musl-gcc-*)
		"$CC" -xc -Wall -Werror -pedantic -pipe -o/dev/null "$@"
		;;
	(tcc|tcc-*)
		# TCC unlinks /dev/null when given -o/dev/null.
		"$CC" -xc -Wall -Werror -pedantic -o"$TMPDIR/a.out" "$@"
		;;
	(icc|icc-*)
		"$CC" -xc -w3 -Wcheck -Werror-all -o/dev/null "$@"
		;;
	(*)
		return 1
		;;
	esac
)



#
# Options
#

OPTIND=1 OPTARG='' opt=''
while getopts Dc:dfj:qh opt; do
	# shellcheck disable=2154
	case $opt in
	(h) exec cat <<EOF >&2
$prog_name - generate a build configuration

Usage:       $prog_name [-cFILE|-d] [-f] [-q] [FILE ...]
             $prog_name -h

Operands:
    FILE     A file to generate (default: $files).

Options:
    -c FILE  Read build configuration from FILE (default: $conf).
    -d       Short for -c devel.env.
    -f       Overwrite existing files. config.h is never overwritten.
    -j N     Run N configuration tests in parallel (default: $maxnjobs).
    -q       Be quiet.
    -h       Show this help screen.

See docs/build.rst for details.

Copyright 2022 and 2023 Odin Kroeger.
Released under the GNU General Public License.
This programme comes with ABSOLUTELY NO WARRANTY.
EOF
		;;
	(D) set -x ;;
	(c) conf="$OPTARG" ;;
	(d) conf=devel.env ;;
	(f) force=x ;;
	(j) maxnjobs="$OPTARG" ;;
	(q) quiet=x ;;
	(*) exit 1
	esac
done
shift $((OPTIND - 1))
unset opt

[ "$conf" ]	|| err '-c: no filename given.'
[ -e "$conf" ]	|| err '%s: no such file.' "$conf"

# shellcheck disable=1090
case $conf in ([!/.]*)
	conf="./$conf"
esac

# shellcheck source=devel.conf
. "$conf" || exit

# shellcheck disable=2086
[ $# -eq 0 ] && set -- $files
unset files

nfiles=0
for file
do
	eval "file_$nfiles"='"$file"'
	nfiles=$((nfiles + 1))
done
shift $#

if [ "$prog_name" = "$confsave" ]
then
	exec >/dev/null
	force=x
fi

# shellcheck disable=2034
readonly conf force quiet maxnjobs nfiles


#
# Architecture
#

printf 'Machine type: '

if machine="$(uname -m)" && [ "$machine" ]
then printf '%s\n' "$machine"
else printf 'detection failed.\a\n'
fi


#
# Operating system
#

printf 'Operating system: '

os="$(uname -s)" osvers="$(uname -r)" || :
if   [ "$os" ] && [ "$osvers" ]
then printf '%s v%s\n' "$os" "$osvers"
elif [ "$os" ]
then printf '%s\n' "$os"
else printf 'detection failed.\a\n'
fi


#
# Check if gcc, clang, tcc, or icc are available.
#

printf 'C compiler: '

: "${CC:=}"
if ! [ "$CC" ]
then
	for cc in $compilers
	do
		if	command -v "$cc" >/dev/null 2>&1 &&
			"$cc" -v 2>&1 | grep -q "$cc"
		then
			CC="$cc"
			break
		fi
	done

	if ! [ "$CC" ]
	then
		for cc in c99 cc
		do
			if command -v "$cc" >/dev/null 2>&1
			then
				CC="$cc"
				break
			fi
		done
	fi

	unset cc
fi

if [ "$CC" ]
then
	printf '%s\n' "$CC"
else
	printf 'none found.\a\n'
	exit 2
fi


#
# Compiler information
#

compcmd="$(basename "$CC")"
compname="${compcmd%% *}"

case $compname in
(clang|clang-*)	comptype=llvm ;;
(musl-*)	comptype=musl_${compname#*-} ;;
(*)		comptype="${compname%%-*}" ;;
esac

compvers="$(
	"$CC" -v 2>&1 |
	awk '{
		for (i = 1; i <= NF; i++) {
			if ($i ~ /^v?[0-9]+\.[0-9]+\./) {
				print $i;
				exit;
			}
		}
	}'
)"

if [ "$compvers" ]
then
	compvers="${compvers#v}"
	compmajor="${compvers%%.*}"
elif [ "${compname#"$comptype"-}" != "$compname" ]
then
	compmajor="${compname#"$comptype"-}"
fi
readonly compcmd compname compvers compmajor


#
# Check which flags the C compiler supports.
#

printf 'Compiler flags:'

if [ "${CFLAGS-x}" = x ] && ! [ "${CFLAGS-}" = x ]
then
	if [ "$compname" = c99 ]
	then
		CFLAGS="-O2 -s"
		printf ' %s\n' "$CFLAGS"
	else
		eval specflags="\${cflags_$comptype-}"

		# shellcheck disable=2086,SC2154
		set -- $cflags $specflags
		njobs=0 jobs=''
		while [ "$njobs" -gt 0 ] || [ $# -gt 0 ]
		do
			# Start jobs.
			while [ "$njobs" -lt "$maxnjobs" ] && [ $# -gt 0 ]
			do
				flag="$1"
				shift

				case $flag in (-D*)
					CFLAGS="${CFLAGS-} $flag"
					continue
				esac

				testflags -E "$flag" /dev/null &

				njobs=$((njobs + 1)) jobs="$jobs$! "
				eval "flag_$!"='$flag'
			done

			# Collect the job on top of the pile.
			job="${jobs%% *}"
			if wait "$job"
			then
				eval flag="\"\${flag_$job-}\""
				unset "flag_$job"
				CFLAGS="${CFLAGS-} $flag"
				printf -- ' %s' "$flag"
			fi
			njobs=$((njobs - 1)) jobs="${jobs#* }"
			unset job
		done

		[ "${CFLAGS-}" ] || printf ' none detected.\a'
		echo
	fi
else
	printf -- ' %s\a\n' "${CFLAGS:-none given.}"
fi
unset cflags flag jobs job


#
# Check which archiver to use.
#

printf 'Archiver: '

if [ "${AR-x}" = x ] && ! [ "${AR-}" = x ]
then
	if [ "${compmajor-}" ]
	then archivers="$comptype-ar-$compmajor $comptype-ar"
	else archivers="$comptype-ar"
	fi

	for archiver in $archivers
	do
		if command -v "$archiver" >/dev/null 2>&1
		then
			AR="$archiver"
			break
		fi
	done

	printf '%s\n' "${AR-default}"
fi


#
# Check what data type getgrouplist returns GIDs as.
#

printf 'getgrouplist group ID type: '

: "${SC_GETGRPLST_T=}"
if ! [ "$SC_GETGRPLST_T" ]
then
	types=gid_t
	for base in 'int' 'short' 'long' 'long long'
	do
		for prefix in '' 'unsigned '
		do
			types="$types:$prefix$base"
		done
	done

	src="$TMPDIR/getgrouplist.c"
	cat <<-'EOF' >"$src"
		#define _BSD_SOURCE
		#define _DARWIN_C_SOURCE
		#define _DEFAULT_SOURCE
		#define _GNU_SOURCE

		#include <grp.h>
		#include <unistd.h>

		int
		main(void)
		{
			GETGRPLST_T basegid = 0;
			GETGRPLST_T groups[1] = {0};
			int n = 1;

			getgrouplist("dummy", basegid, groups, &n);

			return 0;
		}
	EOF

	IFS=:
	for type in $types
	do
		if testcomp -DGETGRPLST_T="$type" "$src"
		then
			SC_GETGRPLST_T="$type"
			break
		fi
	done
	unset IFS src

	if [ "${SC_GETGRPLST_T-}" ]
	then printf '%s\n' "$SC_GETGRPLST_T"
	else printf 'guess at compile-time.\a\n'
	fi
else
	printf '%s\n' "$SC_GETGRPLST_T"
fi


#
# Check what type setgroups takes the groups size as.
#

printf 'setgroups count type: '

: "${SC_SETGRPNUM_T=}"
if ! [ "$SC_SETGRPNUM_T" ] && testflags -Wconversion
then
	types=size_t
	for base in 'int' 'short' 'long' 'long long'
	do
		for prefix in '' 'unsigned '
		do
			types="$types:$prefix$base"
		done
	done

	src="$TMPDIR/setgroups.c"
	cat <<-'EOF' >"$src"
		#define _BSD_SOURCE
		#define _DARWIN_C_SOURCE
		#define _DEFAULT_SOURCE
		#define _GNU_SOURCE

		#include <sys/types.h>
		#include <grp.h>
		#include <unistd.h>

		int
		main(void)
		{
			SETGRPNUM_T ngroups = 0;
			gid_t gidset[1] = {0};

			(void) setgroups(ngroups, gidset);

			return 0;
		}
	EOF

	IFS=:
	for type in $types
	do
		if testcomp -DSETGRPNUM_T="$type" -Wconversion "$src"
		then
			SC_SETGRPNUM_T="$type"
			break
		fi
	done

	unset IFS src
fi

if [ "${SC_SETGRPNUM_T-}" ]
	then printf '%s\n' "$SC_SETGRPNUM_T"
	else printf 'guess at compile-time.\a\n'
fi


#
# Generate M4 command line.
#

shift $#
for key in $macros
do
	eval "value=\"\${$key-}\""
	if [ "$value" ]
	then
		case $# in
		(0) set -- "-D__${key}=${value# }" ;;
		(*) set -- "$@" "-D__${key}=${value# }" ;;
		esac
	fi
done
unset key value


#
# Save configuration.
#

if [ -e "$confsave" ]
	then exists=x
	else exists=
fi

if [ "$prog_name" != "$confsave" ]
then
	if [ "$exists" ] && ! [ "$force" ]
	then
		warn -q '%s exists.' "$confsave"
	else
		swap="$TMPDIR/$confsave"

		cat <<-'EOF' >"$swap"
		#!/bin/sh
		# Last configuration detected by ./configure.

		EOF

		for key in $macros
		do
			case $key in (*[!A-Z_]*)
				continue
			esac

			eval "value=\"\${$key--}\""
			[ "$value" = - ] && continue
			# shellcheck disable=2016
			printf ': "${%s="%s"}"\n' "$key" "${value# }" >>"$swap"
		done
		unset key value

		printf '\n. ./configure\n' >>"$swap"

		chmod +x "$swap"

		mv "$swap" "$confsave"

		if [ "$exists" ]
			then warn -q 'updated %s.' "$confsave"
			else warn -q 'saved configuration in %s.' "$confsave"
		fi
	fi
fi

#
# Create files.
#

i=0
while [ "$i" -lt "$nfiles" ]
do
	eval file="\${file_$i}"
	template="$file.m4" i=$((i + 1))

	exists=
	# shellcheck disable=2154
	if [ -e "$file" ]
	then
		exists=x
		if ! [ "$force" ]
		then
			warn '%s exists.' "$file"
			continue
		fi
	fi

	swap="$TMPDIR/$file"
	if m4 "$@" "$template" >"$swap" 2>/dev/null
	then
		mv "$swap" "$file"
		if [ "$exists" ]
		then warn -q 'updated %s.' "$file"
		else warn -q 'generated %s.' "$file"
		fi
	else
		rm -f "$swap" || :
		err 'could not generate %s.' "$file"
	fi
	unset swap
done


#
# config.h
#

if [ -e config.h ]
then
	cmp -s config.h.sample config.h ||
	warn -q 'config.h and config.h.sample differ, keeping config.h.'
else
	warn -q 'copying config.h.sample to config.h.'
	cp config.h.sample config.h
fi
