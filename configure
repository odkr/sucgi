#!/bin/sh
# Generate a build configuration.
#
# Copyright 2022 and 2023 Odin Kroeger.
#
# This file is part of suCGI.
#
# suCGI is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option)
# any later version.
#
# suCGI is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License
# for more details.
#
# You should have received a copy of the GNU General Public License along
# with suCGI. If not, see <https://www.gnu.org/licenses>.

# shellcheck disable=1091,2015


#
# Defaults
#

# Compiler flags to test for.
cflags=

# Compilers to look for. Space-separated list of commands.
compilers='gcc clang tcc icx icc c99 cc'

# Configuration file.
conf=prod.env

# Files to generate. Space-separated list.
files='compat.h makefile'

# Overwrite existing files?
force=

# Headers to look for. Space-separated list of filenames.
headers='sys/param.h features.h'

# Maximum number of child processes to spawn.
maxnjobs=4
# The Busybox Almquist shell tends to crash when running jobs in parallel.
[ "$(basename "${SHELL-}")" = ash ] && maxnjobs=1

# Be quiet?
quiet=

# Search static code analysers?
statenable=

# Directories to add to $PATH when searching analysers. Colon-separated list.
statpath=

# Conversion warning flags.
wconvflags='-Wincompatible-pointer-types -Wconversion -Wsign-conversion'


#
# Initialisation
#

set -Ceu
src_dir="$(dirname "$0")" || exit
readonly src_dir
cd "$src_dir" || exit
. ./scripts/funcs.sh || exit
init
tmpdir tmp .


#
# Constants
#

# Variables to set as M4 Macros.
readonly macros='
	CC CFLAGS AR ARFLAGS LDFLAGS LDLIBS DESTDIR PREFIX
	SUCGI_GRP_T SUCGI_NGRPS_T SUCGI_HAVE_SYS_PARAM_H SUCGI_HAVE_FEATURES_H
	SUCGI_SHARED_LIBS SUCGI_PRELOAD_VAR SUCGI_CGI_DIR SUCGI_WWW_GRP
	SUCGI_CLANG_TIDY SUCGI_CPPCHECK SUCGI_FLAWFINDER SUCGI_RATS
	SUCGI_SHELLCHECK
'

# Where to save the configuration.
readonly confsave=config.status

# Colon-separated list of integer types used for group IDs and sizes.
inttypes=
for base in 'int' 'long' 'long long'
do
	for prefix in '' 'unsigned '
	do inttypes="$inttypes:$prefix$base"
	done
done
unset base
readonly inttypes

# Colon-separated list of possible data types for group IDs.
readonly grouptypes="gid_t:$inttypes"

# Colon-separated list of possible data types for sizes.
readonly sizetypes="size_t:$inttypes"


#
# Functions
#

# Check if the given compiler supports the given flags.
addflags() {
	case ${1:?} in
	(-*)
		cflags="${cflags-} $*"
		;;
	(*)
		__addflags_var="cflags_$1"
		shift
		eval "$__addflags_var"="\"\${$__addflags_var-} \$*\""
		unset __addflags_var
		;;
	esac
}

# Test compilation.
testcomp() (
	: "${compname:?}" "${testflags?}"

	exec >/dev/null 2>&1

	case $compname in
	(clang|gcc)
		# shellcheck disable=2086
		"$CC" -xc -Wall -Werror $testflags -o/dev/null "$@"
		;;
	(tcc)
		# TCC unlinks /dev/null when given -o/dev/null.
		# shellcheck disable=2086
		"$CC" -Wunsupported \
		      -xc -Wall -Werror $testflags -o"$TMPDIR/a.out" "$@"
		;;
	(icc)
		# shellcheck disable=2086
		"$CC" -diag-enable=10006,10148 -diag-error=10006,10148 \
		      -xc -Wall -Werror $testflags -o/dev/null "$@"
		;;
	(*)
		return 1
		;;
	esac
)

# Test compiler flags.
testflags() {
	printf 'int main(void) {return 0;}\n' |
	testcomp "$@" -
}

# Test whether a header file is available.
testhdr() {
	printf '#include <%s>\n' "${1:?}" |
	testcomp -E -
}


#
# Options
#

OPTIND=1 OPTARG='' opt=''
while getopts Dc:dfhj:p:qs opt
do
	# shellcheck disable=2154
	case $opt in
	(h) exec cat <<EOF >&2
$prog_name - generate a build configuration

Usage:       $prog_name [-cFILE|-d] [-f] [-jN] [-pDIR] [-q] [-s]
                        [MACRO ...] [FILE ...]
             $prog_name -h

Operands:
    MACRO    An M4 macro.
    FILE     A file to generate (default: $files).

Options:
    -c FILE  Read build configuration from FILE (default: $conf).
    -d       Short for -c devel.env.
    -f       Overwrite existing files.
    -j N     Run N configuration tests in parallel (default: $maxnjobs).
    -p DIR   Add DIR to the search path for static analysers.
    -s       Search for static code analysers.
    -q       Be quiet.
    -h       Show this help screen.

See docs/build.rst for details.

Copyright 2022 and 2023 Odin Kroeger.
Released under the GNU General Public License.
This programme comes with ABSOLUTELY NO WARRANTY.
EOF
		;;
	(D) set -x ;;
	(c) conf="$OPTARG" ;;
	(d) conf=devel.env ;;
	(f) force=x ;;
	(j) maxnjobs="$OPTARG" ;;
	(p) statpath="$statpath:$OPTARG" ;;
	(q) quiet=x ;;
	(s) statenable=x ;;
	(*) exit 1
	esac
done
shift $((OPTIND - 1))
unset opt

[ "$conf" ]	|| err '-c: no filename given.'
[ -e "$conf" ]	|| err '%s: no such file.' "$conf"

# shellcheck disable=1090
case $conf in ([!/.]*)
	conf="./$conf"
esac

# shellcheck source=devel.conf
. "$conf" || exit

if [ "$prog_name" = "$confsave" ]
then
	exec >/dev/null
	force=y
fi

# shellcheck disable=2086
[ $# -eq 0 ] && set -- $files
unset files

nfiles=0
for file
do
	eval "file_$nfiles"='"$file"'
	nfiles=$((nfiles + 1))
done
shift $#

# shellcheck disable=2034
readonly conf force quiet maxnjobs nfiles


#
# Library pre-load variable
#

printf 'System: '

uname="$(uname)"

: "${SUCGI_PRELOAD_VAR:=}"
if ! [ "$SUCGI_PRELOAD_VAR" ]
then
	case $uname in
	(Darwin) SUCGI_PRELOAD_VAR=DYLD_INSERT_LIBRARIES ;;
	(*)      SUCGI_PRELOAD_VAR=LD_PRELOAD ;;
	esac
fi

printf '%s\n' "$uname"


#
# Check which compiler is available.
#

printf 'C compiler: '

: "${CC:=}"
if ! [ "$CC" ]
then
	for cc in $compilers
	do
		if	command -v "$cc" >/dev/null 2>&1 &&
			"$cc" -v 2>&1 | grep -q "$cc"
		then
			CC="$cc"
			break
		fi
	done

	if ! [ "$CC" ]
	then
		for cc in c99 cc
		do
			if command -v "$cc" >/dev/null 2>&1
			then
				CC="$cc"
				break
			fi
		done
	fi

	unset cc
fi

if ! [ "$CC" ]
then
	printf 'none found\a\n'
	exit 2
fi

# Compiler path.
set -- "$CC"
comppath="${1:?}"
readonly comppath

# Compiler executable.
compexec="$(basename "${comppath:?}")"
readonly compexec

# Compiler name.
case $compexec in
(musl-*) compname="${compexec##musl-}"
esac
compname="${compexec%%[!a-z]*}"
readonly compname

# Compiler command prefix.
case $compname in
(clang)	compprefix=llvm ;;
(*)	compprefix="$compname" ;;
esac
readonly compprefix

# Compiler flags useful for testing compiler features.
testflags=
if ! [ "${CFLAGS-}" ] || ! [ "${SUCGI_GRP_T-}" ] || ! [ "${SUCGI_NGRPS_T}" ]
then
	for flag in -Wextra -Wpedantic -pedantic -pipe
	do testflags $flag && testflags="$testflags $flag"
	done
	unset flag
fi
readonly testflags

# Output.
printf '%s\n' "$CC"


#
# Check which flags the C compiler supports.
#

printf 'Compiler flags:'

if [ "${CFLAGS-x}" = x ] && ! [ "${CFLAGS-}" = x ]
then
	if [ "$compname" = c99 ]
	then
		CFLAGS="-O2 -s"
		printf ' %s\n' "$CFLAGS"
	else
		eval specflags="\${cflags_$compprefix-}"

		# shellcheck disable=2086,SC2154
		set -- $cflags $specflags
		njobs=0 jobs=''
		while [ "$njobs" -gt 0 ] || [ $# -gt 0 ]
		do
			# Start jobs.
			while [ "$njobs" -lt "$maxnjobs" ] && [ $# -gt 0 ]
			do
				flag="$1"
				shift

				case $flag in (-D*)
					CFLAGS="${CFLAGS-} $flag"
					continue
				esac

				testflags "$flag" &

				njobs=$((njobs + 1)) jobs="$jobs$! "
				eval "flag_$!"='$flag'
				unset flag
			done

			# Collect the job on top of the pile.
			job="${jobs%% *}"
			if wait "$job"
			then
				eval flag="\"\${flag_$job-}\""
				unset "flag_$job"
				CFLAGS="${CFLAGS-} $flag"
				printf -- ' %s' "$flag"
			fi
			njobs=$((njobs - 1)) jobs="${jobs#* }"
			unset job
		done

		[ "${CFLAGS-}" ] || printf ' none detected'

		echo
		unset jobs specflags
	fi
else
	printf -- ' %s\a\n' "${CFLAGS:-none given}"
fi
unset cflags


#
# Check whether the compiler supports -shared.
#

printf 'Supports shared libraries: '

if [ "${SUCGI_SHARED_LIBS-x}" = x ] && [ "${SUCGI_SHARED_LIBS-}" != x ]
then
	if testflags -shared -fpic
	then SUCGI_SHARED_LIBS=y
	else SUCGI_SHARED_LIBS=
	fi
fi

if [ "$SUCGI_SHARED_LIBS" ]
then printf 'yes\n'
else printf 'no\n'
fi


#
# Check which archiver to use.
#

printf 'Archiver: '

if [ "${AR-x}" = x ] && ! [ "${AR-}" = x ]
then
	# Compiler version.
	compvers="$(
		"$CC" -v 2>&1 |
		awk '{
			for (i = 1; i <= NF; i++) {
				if ($i ~ /^v?[0-9]+\.[0-9]+\./) {
					gsub("[^0-9\.]", "", $i);
					print $i;
					exit;
				}
			}
		}' 2>/dev/null
	)"

	if [ "$compvers" ]
	then
		compmajor="${compvers%%.*}"
	else
		case $compexec in
		(*[0-9]*)
			prefix="${compexec%%[0-9]*}"
			compmajor="${compexec#"$prefix"}"
			;;
		(*)
			compmajor=
			;;
		esac
	fi
	readonly compvers compmajor

	if [ "${compmajor-}" ]
	then archivers="
		$compprefix-ar-$compmajor
		$compprefix-ar$compmajor
		$compprefix-ar
	"
	else archivers="$compprefix-ar"
	fi

	for archiver in $archivers
	do
		if command -v "$archiver" >/dev/null 2>&1
		then
			AR="$archiver"
			break
		fi
	done
fi

printf '%s\n' "${AR-default}"


#
# Check which headers are available.
#

printf 'Headers:'

# shellcheck disable=2086,SC2154
set -- $headers
nheaders=0 njobs=0 jobs=''
while [ "$njobs" -gt 0 ] || [ $# -gt 0 ]
do
	# Start jobs.
	while [ "$njobs" -lt "$maxnjobs" ] && [ $# -gt 0 ]
	do
		header="$1"
		shift

		headervar="SUCGI_HAVE_$(
			printf '%s\n' "$header"	|
			sed 's/[^a-z]/_/g'	|
			tr '[:lower:]' '[:upper:]'
		)"

		case $headervar in (HAVE_|*[!A-Z0-9_]*)
			warn '%s: could not derive macro name.'
			continue
		esac

		eval headeravail="\${$headervar-}"

		# shellcheck disable=2154
		case $headeravail in
		(0)
			eval "$headervar=0"
			;;
		(1)
			eval "$headervar=1"
			nheaders=$((nheaders + 1))
			printf ' %s' "$header"
			;;
		(*)
			testhdr "$header" &
			njobs=$((njobs + 1)) jobs="$jobs$! "
			eval "header_$!"='$header'
			eval "headervar_$!"='$headervar'
		esac

		unset header headervar headeravail
	done

	# Collect the job on top of the pile.
	if [ "$njobs" -gt 0 ]
	then
		job="${jobs%% *}"
		eval header="\"\${header_$job-}\""
		eval headervar="\"\${headervar_$job-}\""
		unset "header_$job" "headervar_$job"

		if wait "$job"
		then
			eval "$headervar=1"
			nheaders=$((nheaders + 1))
			printf -- ' %s' "$header"
		else
			eval "$headervar=0"
		fi

		njobs=$((njobs - 1)) jobs="${jobs#* }"
		unset header headervar job
	fi
done

case $nheaders in
(0) printf ' none found\n' ;;
(*) printf '\n' ;;
esac


#
# Check what data type getgrouplist returns GIDs as.
#

printf 'getgrouplist GID type: '

: "${SUCGI_GRP_T=}"
# shellcheck disable=2086
if ! [ "$SUCGI_GRP_T" ] && testflags $wconvflags
then
	src="$TMPDIR/getgroups.c"
	cat <<-'EOF' >"$src"
		#define _BSD_SOURCE
		#define _DARWIN_C_SOURCE
		#define _DEFAULT_SOURCE
		#define _GNU_SOURCE

		#include <grp.h>
		#include <unistd.h>

		int
		main(void)
		{
			SUCGI_GRP_T basegid = 0;
			SUCGI_GRP_T groups[1] = {0};
			int n = 1;

			getgrouplist("dummy", basegid, groups, &n);

			return 0;
		}
	EOF

	IFS=:
	for grouptype in $grouptypes
	do
		unset IFS || :
		[ "$grouptype" ] || continue

		# shellcheck disable=2086
		if testcomp $wconvflags -DSUCGI_GRP_T="$grouptype" "$src"
		then
			SUCGI_GRP_T="$grouptype"
			break
		fi
	done
	unset src grouptype
fi

if [ "$SUCGI_GRP_T" ]
then printf '%s\n' "$SUCGI_GRP_T"
else printf 'guess at compile-time\n'
fi


#
# Check what data type setgroups takes the group size as.
#

printf 'setgroups count type: '

: "${SUCGI_NGRPS_T=}"
# shellcheck disable=2086
if ! [ "$SUCGI_NGRPS_T" ] && testflags $wconvflags
then
	src="$TMPDIR/setgroups.c"
	cat <<-'EOF' >"$src"
		#define _BSD_SOURCE
		#define _DARWIN_C_SOURCE
		#define _DEFAULT_SOURCE
		#define _GNU_SOURCE

		#include <sys/types.h>
		#include <grp.h>
		#include <unistd.h>

		int
		main(void)
		{
			SUCGI_NGRPS_T ngroups = 0;
			gid_t gidset[1] = {0};

			(void) setgroups(ngroups, gidset);

			return 0;
		}
	EOF

	IFS=:
	for sizetype in $sizetypes
	do
		unset IFS || :
		[ "$sizetype" ] || continue

		# shellcheck disable=2086
		if testcomp $wconvflags -DSUCGI_NGRPS_T="$sizetype" "$src"
		then
			SUCGI_NGRPS_T="$sizetype"
			break
		fi
	done
	unset src sizetype
fi

if [ "$SUCGI_NGRPS_T" ]
then printf '%s\n' "$SUCGI_NGRPS_T"
else printf 'guess at compile-time\n'
fi


#
# Static Code Analysers
#

if [ "$statenable" ]
then
	printf 'Static analysers:'

	nanalysers=0

	# Extend $PATH for search analysers.
	if [ "$statpath" ]
	then
		IFS=:
		for dir in $statpath
		do
			unset IFS
			case $PATH in
			("$dir":|:"$dir"|:"$dir":) : ;;
			(*) [ -e "$dir" ] && PATH="$dir:$PATH"
			esac
		done
		export PATH
	fi

	# Clang-tidy
	: "${SUCGI_CLANG_TIDY=$(command -v clang-tidy 2>/dev/null)}"
	if [ "$SUCGI_CLANG_TIDY" ]
	then
		nanalysers=$((nanalysers + 1))
		printf ' clang-tidy'
	fi

	# Cppcheck
	: "${SUCGI_CPPCHECK=$(command -v cppcheck 2>/dev/null)}"
	if [ "$SUCGI_CPPCHECK" ]
	then
		nanalysers=$((nanalysers + 1))
		printf ' cppcheck'
	fi

	# Flawfinder
	: "${SUCGI_FLAWFINDER=$(command -v flawfinder 2>/dev/null)}"
	if [ "$SUCGI_FLAWFINDER" ]
	then
		nanalysers=$((nanalysers + 1))
		printf ' flawfinder'
	fi

	# RATS
	: "${SUCGI_RATS=$(command -v rats 2>/dev/null)}"
	if [ "$SUCGI_RATS" ]
	then
		nanalysers=$((nanalysers + 1))
		printf ' rats'
	fi

	# ShellCheck
	: "${SUCGI_SHELLCHECK=$(command -v shellcheck 2>/dev/null)}"
	if [ "$SUCGI_SHELLCHECK" ]
	then
		printf ' shellcheck'
		nanalysers=$((nanalysers + 1))
	fi

	[ "$nanalysers" -eq 0 ] && printf ' none found'
	echo
fi


#
# Generate M4 command line.
#

shift $#
for key in $macros
do
	eval "value=\"\${$key-}\""
	if [ "$value" ]
	then
		case $# in
		(0) set -- "-D__${key}=\`${value# }'" ;;
		(*) set -- "$@" "-D__${key}=\`${value# }'" ;;
		esac
	fi
done
unset key value


#
# Save configuration.
#

if [ -e "$confsave" ]
	then exists=x
	else exists=
fi

if [ "$prog_name" != "$confsave" ]
then
	if [ "$exists" ] && ! [ "$force" ]
	then
		err '%s exists, give -f to overwrite.' "$confsave"
	else
		swap="$TMPDIR/$confsave"

		cat <<-'EOF' >"$swap"
		#!/bin/sh
		# Last configuration detected by ./configure.

		EOF

		for key in $macros
		do
			eval "value=\"\${$key--}\""
			[ "$value" = - ] && continue
			# shellcheck disable=2016
			printf ': "${%s="%s"}"\n' "$key" "${value# }" >>"$swap"
		done
		unset key value

		cat <<-'EOF' >>"$swap"

		. ./configure
		EOF

		chmod +x "$swap"

		if [ "$exists" ]
		then
			if cmp "$swap" "$confsave" >/dev/null 2>&1
			then
				warn -q 'no changes to %s.' "$confsave"
			else
				warn -q 'updating %s ...' "$confsave"
				mv -f "$swap" "$confsave"
			fi
		else
			warn -q 'creating %s ...' "$confsave"
			mv -f "$swap" "$confsave"
		fi
	fi
fi


#
# Create files.
#

i=0
while [ "$i" -lt "$nfiles" ]
do
	eval file="\${file_$i}"
	template="$file.m4" i=$((i + 1))

	exists=
	# shellcheck disable=2154
	if [ -e "$file" ]
	then
		exists=x
		if ! [ "$force" ]
		then
			warn '%s exists.' "$file"
			continue
		fi
	fi

	swap="$TMPDIR/$file"
	if m4 "$@" "$template" >"$swap"
	then
		if [ "$exists" ]
		then
			if cmp "$swap" "$file" >/dev/null 2>&1
			then
				warn -q 'no changes to %s.' "$file"
				continue
			else
				warn -q 'updating %s ...' "$file"
			fi
		else
			warn -q 'creating %s ...' "$file"
		fi

		mv -f "$swap" "$file"
	else
		rm -f "$swap" || :
		err 'could not generate %s.' "$file"
	fi
	unset swap
done
