#!/bin/sh

#
# Run checks using different systems.
#
# Copyright 2023 Odin Kroeger.
#
# This file is part of suCGI.
#
# suCGI is free software: you can redistribute it and/or modify it
# under the terms of the GNU Affero General Public License as published
# by the Free Software Foundation, either version 3 of the License,
# or (at your option) any later version.
#
# suCGI is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
# or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General
# Public License for more details.
#
# You should have received a copy of the GNU Affero General Public
# License along with suCGI. If not, see <https://www.gnu.org/licenses/>.
#

# shellcheck disable=2015


#
# Defaults
#

# Hosts to test on.
readonly systems='aristides diotima phaedo phaedrus'

# Branch to run tests on.
branch=devel

# Check command to run.
check="scripts/checkall -v"

# Repository directory on the virtual machine.
dir='repos/sucgi'

# Be quieter?
quiet=

# Be verbose?
verbose=

# How many seconds to wait for a VM to become reachable.
timeout=120


#
# Initialiation
#

set -Cefu
scriptsdir="$(cd -P "$(dirname -- "$0")" && pwd)"
: "${scriptsdir:?}"
readonly scriptsdir

srcdir="$(dirname -- "$scriptsdir")"
: "${srcdir:?}"
readonly srcdir

# shellcheck disable=2154
export PATH="$srcdir/tests:$srcdir/utils:$PATH"

# shellcheck disable=1091
. "$scriptsdir/../libutil.sh"	|| exit
init				|| exit
tmpdir chk "$srcdir"		|| exit


#
# Constants
#

# Current working directory
cwd="$(pwd)" || exit
: "${cwd:?}"
readonly cwd

# User who should own the logs.
if [ "$(id -u)" -eq 0 ]
then user="$(owner "$srcdir")"
else user="$(id -un)"
fi
: "${user:?}"
readonly user

# The primary group of that user.
group="$(id -gn "$user")"
: "${group:?}"
readonly group


#
# Globals
#

# Host most recently connected to.
host=

# The most recently start VM, if any.
started_vm=

# Temporary directory created on the host.
tmpdir=

# Whether UTM has been started by this script.
# shellcheck disable=2034
utm_started=


#
# Functions
#

my_logged() {
	: "${1:?}"

	case $1 in
	(-*) logged -d"$cwd" -u"$user" -g"$group" "$@" ;;
	(*)  logged -d"$cwd" -u"$user" -g"$group" -- "$@" ;;
	esac
}

utm_is_running() {
	ps -A -ocomm= | xargs basename | grep -q UTM
}

utm_get_ip() {
	# shellcheck disable=2034
	utm_is_running || utm_started=y
	utmctl ip-address "${1:?}" 2>/dev/null | grep -Ev ^fe80: | head -n1
}

utm_is_vm() {
	# shellcheck disable=2034
	utm_is_running || utm_started=y
	# shellcheck disable=2046
	inlist '=' "${1:?}" $(utmctl list | awk 'NR > 1 {print $3}')
}

utm_vm_started() {
	# shellcheck disable=2034
	utm_is_running || utm_started=y
	[ "$(utm_status "$1")" = started ] >/dev/null 2>&1
}

utm_quit() (
	warn -qv 'waiting for virtual machines to shut down ...'

	i=0
	while [ "$i" -lt "$timeout" ]
	do
		i=$((i + 1))

		utmctl list 					|
		awk 'NR > 1 && $2 != "stopped" {exit 1}'	&&
		break

		sleep 1
	done

	# Give the VM time to shut down.
	while [ "$i" -lt "$timeout" ]
	do
		i=$((i + 1))

		ps -A -ocomm= 		|
		xargs basename 		|
		grep -iqE ^qemulauncher ||
		break

		sleep 1
	done

	warn -qv 'telling UTM to quit ...'
	if command -v osascript >/dev/null 2>&1
	then osascript -e 'tell application "UTM" to quit'
	else killall UTM
	fi
)

utm_status() {
	# shellcheck disable=2034
	utm_is_running || utm_started=y
	utmctl status "${1:?}" 2>/dev/null
}

utm_start_vm() {
	: "${1:?}"

	# shellcheck disable=2034
	utm_is_running || utm_started=y
	if ! utm_vm_started "$1"
	then
		warn -qv 'starting %s ...' "$1"
		utmctl start "$1"
	fi
}

utm_stop_vm() {
	: "${1:?}"

	# shellcheck disable=2034
	utm_is_running || utm_started=y
	if utm_vm_started "$1"
	then
		warn -qv 'stopping %s ...' "$1"
		utmctl stop "$1" || :
	fi
}

remote_branch_stash() {
	: "${1:?}" "${2:?}" "${3:?}"

	ssh -q "$1" "
		cd '$2' 	&&
		git branch -q --show-current" &&
	ssh -q "$1" "
		cd '$2' 	&&
		git stash -q	&&
		git checkout -q '$3'
	"
}

remote_branch_restore() {
	: "${1:?}" "${2:?}" "${3:?}"

	ssh -q "$1" "
		cd '$2'			&&
		git checkout -q '$3'	&&
		git stash apply -q
	"
}


#
# Options
#

OPTIND=1 OPTARG='' opt=''
while getopts Db:c:d:hqt:v opt; do
	# shellcheck disable=2154
	case $opt in
	(h) exec cat <<EOF
$progname - run tests with different virtual machines

Usage:         $progname [HOST ...]
               $progname -h

Operands:
    HOST       A host/UTM virtual machine name.

Options:
    -b BRANCH  Branch to checkout (default: $branch).
    -c CHECK   Check to run (default: $check).
    -d DIR     Repository directory on VM (default: $dir).
    -t N       Wait at most N seconds for VM to boot (default: $timeout).
    -q         Be quieter.
    -v         Be verbose, but do not log runs.
    -h         Show this help screen.
EOF
	    ;;
	(D) set -x ;;
	(b) branch="$OPTARG" ;;
	(c) check="$OPTARG" ;;
	(d) dir="$OPTARG" ;;
	(t) timeout="$OPTARG" ;;
	(q) # shellcheck disable=2034
	    quiet=y ;;
	(v) verbose=y ;;
	(*) exit 1
	esac
done
shift $((OPTIND - 1))
unset opt

# shellcheck disable=2034
readonly branch check dir timeout quiet verbose

case $timeout in (*[!0-9]*)
	err -- '-t: %s: not a number.' "$timeout"
esac

# shellcheck disable=2086
[ $# -eq 0 ] && set -- $systems


#
# Distribution
#

warn -q 'making distribution tarball ...'
cd "$srcdir" || exit
m4 ./makefile.m4 >"$TMPDIR/makefile"
distdir="$TMPDIR/dist" tarball="sucgi-cur.tgz"
my_logged make -f "$TMPDIR/makefile" distname="$distdir" "$distdir"

(
	cd "$distdir" || exit
	m4 ./makefile.m4 >makefile
	my_logged make dist_ar="$TMPDIR/$tarball" version=cur distcheck
)


#
# Main
#

cleanup="
	[ \"\$host\" ] && [ \"\$tmpdir\" ] && ssh \"\$host\" \"rm -rf '\$tmpdir'\"
	[ \"\$started_vm\" ] && utm_stop_vm \"\$started_vm\"
	[ \"\$utm_started\" ] && utm_quit
	${cleanup-}
"
failures=
for sys
do
	warn 'checking with %s ... ' "$sys"

	if utm_is_vm "$sys"
	then vm="$sys"
	else vm=
	fi

	if [ "$vm" ] && ! utm_vm_started "$vm"
	then
		catch='' caught=''
		utm_start_vm "$vm"
		started_vm="$vm"
		catch=y
		[ "$caught" ] && kill -s "$caught" "$$"
	fi

	warn -qv 'waiting for %s to respond ...' "$sys"

	set +e
	catch='' caught='' pid="$$"
	( sleep "$timeout" & wait $! && kill -s ALRM -- "-$pid"; ) & alarm=$!

	while ! [ "$caught" ]
	do
		if [ "$vm" ] && ip="$(utm_get_ip "$vm")"
		then host="${ip:="$vm"}"
		else host="$sys"
		fi

		ssh "$host" -oConnectTimeout=1 true && break
	done >/dev/null 2>&1

	kill "$alarm" >/dev/null 2>&1
	set -e

	catch=y
	case "$caught" in
	(ALRM) err 'connection failure.' ;;
	('')   : ;;
	(*)    kill -s "$caught" "$$"
	esac

	warn -qv 'copying distribution tarball ...'

	tmpdir="$progname-$$"
	ssh -q "$host" "mkdir -m0755 '$tmpdir'"
	scp -q "$TMPDIR/$tarball" "$host:$tmpdir/$tarball"
	ssh -q "$host" "
		cd '$tmpdir' &&
		tar -xzf '$tarball' &&
		find . -name '._*' -exec rm '{}' +
	"

	logfile="$TMPDIR/$sys.log"
	if ! (
		[ "$verbose" ] || exec >"$logfile" 2>&1

		# shellcheck disable=2029
		ssh "$host" "
			set -ex
			cd \"$tmpdir/sucgi-cur\"
			$check
		"
	)
	then
		if ! [ "$verbose" ]
		then
			warn 'testing with %s failed.' "$sys"
			warn 'see %s for details.' "$(basename "$logfile")"
			[ -e "$logfile" ] && mv -f "$logfile" "$cwd"
		fi
		failures="$failures $sys"
	fi

	catch='' caught=''
	# shellcheck disable=2029
	ssh "$host" "rm -rf '$tmpdir'"
	host='' tmpdir=''
	catch=y
	[ "$caught" ] && kill -s "$caught" "$pid"

	catch='' caught=''
	[ "$started_vm" ] && utm_stop_vm "$started_vm"
	started_vm=
	# shellcheck disable=2034
	catch=y
	[ "$caught" ] && kill -s "$caught" "$pid"
done

if [ "$failures" ]
then err -s70 'failures: %s' "${failures# }"
else warn -q 'all tests passed.'
fi
